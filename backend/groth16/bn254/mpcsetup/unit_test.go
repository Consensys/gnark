package mpcsetup

import (
	"bytes"
	"fmt"
	"github.com/consensys/gnark-crypto/ecc"
	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	"github.com/consensys/gnark/backend/groth16"
	groth16Impl "github.com/consensys/gnark/backend/groth16/bn254"
	"github.com/stretchr/testify/require"
	"math/big"
	"testing"
)

// small tests for sub-functionalities of the mpc setup
// this file is not autogenerated, and not generified for other curves

func TestContributionPok(t *testing.T) {
	const (
		pokChallenge = "challenge"
		pokDst       = 1
	)
	x0, err := curve.HashToG1([]byte("contribution test"), nil)
	require.NoError(t, err)
	proof, d := updateValue(x0, []byte(pokChallenge), pokDst)
	var (
		x1 curve.G1Affine
		dI big.Int
	)
	d.BigInt(&dI)
	x1.ScalarMultiplication(&x0, &dI)

	// verify proof - no G2
	require.NoError(t, proof.verify(pair{x0, nil}, pair{x1, nil}, []byte(pokChallenge), pokDst))

	// verify proof - with G2
	y0, err := curve.RandomOnG2()
	require.NoError(t, err)
	var y1 curve.G2Affine
	y1.ScalarMultiplication(&y0, &dI)

	require.NoError(t, proof.verify(pair{x0, &y0}, pair{x1, &y1}, []byte(pokChallenge), pokDst))

	// read/write round-trip
	var bb bytes.Buffer
	n0, err := proof.WriteTo(&bb)
	require.NoError(t, err)
	var proofBack valueUpdate
	n1, err := proofBack.ReadFrom(&bb)
	require.NoError(t, err)
	require.Equal(t, n0, n1)

	require.NoError(t, proofBack.verify(pair{x0, nil}, pair{x1, nil}, []byte(pokChallenge), pokDst))
	require.NoError(t, proofBack.verify(pair{x0, &y0}, pair{x1, &y1}, []byte(pokChallenge), pokDst))
}

// TestSetupBeaconOnly tests the setup/key extraction
// as well as the random beacon contribution
// without any untrusted contributors
func TestSetupBeaconOnly(t *testing.T) {

	// Compile the circuit
	ccs := getTestCircuit(t)
	domainSize := ecc.NextPowerOfTwo(uint64(ccs.GetNbConstraints()))

	var (
		p1 Phase1
		p2 Phase2
	)
	p1.Initialize(domainSize)
	commons := p1.Seal([]byte("beacon 1"))

	evals := p2.Initialize(ccs, &commons)
	pk, vk := p2.Seal(&commons, &evals, []byte("beacon 2"))

	_pk := pk.(*groth16Impl.ProvingKey)
	//_vk := vk.(*groth16Impl.VerifyingKey)

	rpk, rvk, err := groth16.Setup(ccs)
	require.NoError(t, err)
	_rpk := rpk.(*groth16Impl.ProvingKey)

	// assert everything is of the same size
	require.Equal(t, _rpk.Domain.Cardinality, _pk.Domain.Cardinality)
	require.Equal(t, len(_rpk.G1.A), len(_pk.G1.A))
	require.Equal(t, len(_rpk.G1.B), len(_pk.G1.B))
	require.Equal(t, len(_rpk.G1.K), len(_pk.G1.K))
	require.Equal(t, len(_rpk.G1.Z), len(_pk.G1.Z))
	require.Equal(t, len(_rpk.G2.B), len(_pk.G2.B))
	require.Equal(t, len(_rpk.CommitmentKeys), len(_pk.CommitmentKeys))
	for i := range _rpk.CommitmentKeys {
		require.Equal(t, len(_rpk.CommitmentKeys[i].BasisExpSigma), len(_pk.CommitmentKeys[i].BasisExpSigma))
		require.Equal(t, len(_rpk.CommitmentKeys[i].Basis), len(_pk.CommitmentKeys[i].Basis))
	}

	proveVerifyCircuit(t, rpk, rvk)
	fmt.Println("regular proof verified")
	proveVerifyCircuit(t, pk, vk)
}
