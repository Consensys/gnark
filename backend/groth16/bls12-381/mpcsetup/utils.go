// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package mpcsetup

import (
	curve "github.com/consensys/gnark-crypto/ecc/bls12-381"
	"github.com/consensys/gnark-crypto/ecc/bls12-381/fr"
	gcUtils "github.com/consensys/gnark-crypto/utils"
	"github.com/consensys/gnark/internal/utils"
	"math/big"
	"math/bits"
	"sync"
)

func bitReverse[T any](a []T) {
	n := uint64(len(a))
	nn := uint64(64 - bits.TrailingZeros64(n))

	for i := uint64(0); i < n; i++ {
		irev := bits.Reverse64(i) >> nn
		if irev > i {
			a[i], a[irev] = a[irev], a[i]
		}
	}
}

// Returns [1, a, a¬≤, ..., a·¥∫‚Åª¬π ]
func powers(a *fr.Element, N int) []fr.Element {
	if N == 0 {
		return nil
	}
	result := make([]fr.Element, N)
	result[0].SetOne()
	for i := 1; i < N; i++ {
		result[i].Mul(&result[i-1], a)
	}
	return result
}

// Returns [a·µ¢A·µ¢, ...]‚ààùîæ‚ÇÅ
// it assumes len(A) ‚â§ len(a)
func scaleG1InPlace(A []curve.G1Affine, a []fr.Element) {
	/*if a[0].IsOne() {
		A = A[1:]
		a = a[1:]
	}*/
	utils.Parallelize(len(A), func(start, end int) {
		var tmp big.Int
		for i := start; i < end; i++ {
			a[i].BigInt(&tmp)
			A[i].ScalarMultiplication(&A[i], &tmp)
		}
	})
}

// Returns [a·µ¢A·µ¢, ...]‚ààùîæ‚ÇÇ
// it assumes len(A) ‚â§ len(a)
func scaleG2InPlace(A []curve.G2Affine, a []fr.Element) {
	/*if a[0].IsOne() {
		A = A[1:]
		a = a[1:]
	}*/
	utils.Parallelize(len(A), func(start, end int) {
		var tmp big.Int
		for i := start; i < end; i++ {
			a[i].BigInt(&tmp)
			A[i].ScalarMultiplication(&A[i], &tmp)
		}
	})
}

// TODO @Tabaie replace with batch subgroup check, when available
func areInSubGroupG1(wp *gcUtils.WorkerPool, s []curve.G1Affine, errorReporter func(int)) *sync.WaitGroup {
	return wp.Submit(len(s), func(start, end int) {
		for i := start; i < end; i++ {
			if !s[i].IsInSubGroup() {
				errorReporter(i)
				break
			}
		}
	}, 1024) // TODO @Tabaie experimentally optimize minBlock
}

// TODO @Tabaie replace with batch subgroup check, when available
func areInSubGroupG2(wp *gcUtils.WorkerPool, s []curve.G2Affine, errorReporter func(int)) *sync.WaitGroup {
	return wp.Submit(len(s), func(start, end int) {
		for i := start; i < end; i++ {
			if !s[i].IsInSubGroup() {
				errorReporter(i)
				break
			}
		}
	}, 1024) // TODO @Tabaie experimentally optimize minBlock
}

type verificationSettings struct {
	wp *gcUtils.WorkerPool
}

type verificationOption func(*verificationSettings)

func WithWorkerPool(wp *gcUtils.WorkerPool) verificationOption {
	return func(s *verificationSettings) {
		s.wp = wp
	}
}
