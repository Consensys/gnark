// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

pragma solidity ^0.8.0;

contract PlonkVerifier {

  uint256 private constant R_MOD = 52435875175126190479447740508185965837690552500527637822603658699938581184513;
  uint256 private constant R_MOD_MINUS_ONE = 52435875175126190479447740508185965837690552500527637822603658699938581184512;
  
  uint256 private constant G2_SRS_0_X_0_lo = 89961632905173714226157479458612185649920463576279427516307505038263245192632;
	uint256 private constant G2_SRS_0_X_0_hi = 3045985886519456750490515843806728273;
  uint256 private constant G2_SRS_0_X_1_lo = 40446337346877272185227670183527379362551741423616556919902061939448715946878;
  uint256 private constant G2_SRS_0_X_1_hi = 26419286191256893424348605754143887205;
  uint256 private constant G2_SRS_0_Y_0_lo = 78698209480990513415779284580404715789311803115477290401294577488850054555649;
  uint256 private constant G2_SRS_0_Y_0_hi = 17144095208600308495026432580569150746;
  uint256 private constant G2_SRS_0_Y_1_lo = 91929332261301883145239454754739358796115486554644188311284324629555800144318;
  uint256 private constant G2_SRS_0_Y_1_hi = 8010509799087472606393075511737879449;
  
  uint256 private constant G2_SRS_1_X_0_lo = 33364161898139234121223649560040456559045135275061241618520235949685308410562;
	uint256 private constant G2_SRS_1_X_0_hi = 18485093609145557961945058921462472660;
  uint256 private constant G2_SRS_1_X_1_lo = 47343815514628804509513064001044388409857906473491202078034195621463395168418;
  uint256 private constant G2_SRS_1_X_1_hi = 6400975016401570354081307114406190478;
  uint256 private constant G2_SRS_1_Y_0_lo = 101906851828126688602810303985976543158833897347846540361974353257014630075639;
  uint256 private constant G2_SRS_1_Y_0_hi = 31117413519291260242476706907468075405;
  uint256 private constant G2_SRS_1_Y_1_lo = 74490770499585621051767826616592105701789156055368355483473690551245000412820;
  uint256 private constant G2_SRS_1_Y_1_hi = 21720125128319025967711170737383818793;
  
  uint256 private constant G1_SRS_X_lo = 88385725958748408079899006800036250932223001591707578097800747617502997169851;
	uint256 private constant G1_SRS_X_hi = 31827880280837800241567138048534752271;
  uint256 private constant G1_SRS_Y_lo = 114417265404584670498511149331300188430316142484413708742216858159411894806497;
  uint256 private constant G1_SRS_Y_hi = 11568204302792691131076548377920244452;

  // ----------------------- vk ---------------------
  uint256 private constant VK_NB_PUBLIC_INPUTS = 3;
  uint256 private constant VK_DOMAIN_SIZE = 16;
  uint256 private constant VK_INV_DOMAIN_SIZE = 49158632976680803574482256726424342972834892969244660458690930031192419860481;
  uint256 private constant VK_OMEGA = 14788168760825820622209131888203028446852016562542525606630160374691593895118;
  uint256 private constant VK_QL_COM_X_lo = 18702644618746837311565233393995468100394025842697693627106485692434819877808;
	uint256 private constant VK_QL_COM_X_hi = 4033416447930984309949473112804588365;
  uint256 private constant VK_QL_COM_Y_lo = 91187723929844600559567109661036567684650891218217437288064652739821899148825;
  uint256 private constant VK_QL_COM_Y_hi = 21123689617061833672882094227060311286;
  uint256 private constant VK_QR_COM_X_lo = 34780979832570162312684390134327209097079912812228988861402337261542476798047;
  uint256 private constant VK_QR_COM_X_hi = 15417626977942463503164602828591053427;
  uint256 private constant VK_QR_COM_Y_lo = 94631209021393798644934351189345330392905610290828839571715933603830578440753;
  uint256 private constant VK_QR_COM_Y_hi = 17481391663320479961711901868040284015;
  uint256 private constant VK_QM_COM_X_lo = 20993596948425862712170829250030532863490503092201584239591082822505798633407;
  uint256 private constant VK_QM_COM_X_hi = 28536368827382096187180527052087141894;
  uint256 private constant VK_QM_COM_Y_lo = 108502736751659309380225675854674508856825469447697320551580945272405641738168;
  uint256 private constant VK_QM_COM_Y_hi = 30381279966781979963982094964412329764;
  uint256 private constant VK_QO_COM_X_lo = 89486254922091951746889192121904848241662022236051913598986078658200923260121;
  uint256 private constant VK_QO_COM_X_hi = 22267457232035048545743339797310885345;
  uint256 private constant VK_QO_COM_Y_lo = 96942295814280852454692728560941106331118120437130251717101825515762334753998;
  uint256 private constant VK_QO_COM_Y_hi = 23978880976942474288727435441819196073;
  uint256 private constant VK_QK_COM_X_lo = 75950713458154455640954500528821469160784615655570693535412028244088187163200;
  uint256 private constant VK_QK_COM_X_hi = 32716850844776185850775733804821457379;
  uint256 private constant VK_QK_COM_Y_lo = 94938020662326842962042989290594237271808747194523575487714780718610401717348;
  uint256 private constant VK_QK_COM_Y_hi = 15774620185524187841096777209627112205;
  
  uint256 private constant VK_S1_COM_X_lo = 63461063047705767613355294193600152277004663146949666571091737034968725444993;
	uint256 private constant VK_S1_COM_X_hi = 33254908828606133798153682393445181407;
  uint256 private constant VK_S1_COM_Y_lo = 20115155937007988321969483545850341408072352633468951458022192655177260588941;
  uint256 private constant VK_S1_COM_Y_hi = 4708076134213790745154988139987765002;
  
  uint256 private constant VK_S2_COM_X_lo = 71755230736043833037923381512549164108897017258485182483367411382531356239241;
	uint256 private constant VK_S2_COM_X_hi = 772092675800698355529868331467384945;
  uint256 private constant VK_S2_COM_Y_lo = 111203009011023333881639647010052350561734770553763374999701012870001791984619;
  uint256 private constant VK_S2_COM_Y_hi = 33971632076781669943691314804139563063;
  
  uint256 private constant VK_S3_COM_X_lo = 77381952516422764414828706935597674438202447053180503994803331944782478500977;
	uint256 private constant VK_S3_COM_X_hi = 5024818710421565518784731845012754999;
  uint256 private constant VK_S3_COM_Y_lo = 74939617040114884471958018324824778405955819793190904306876476244930372031413;
  uint256 private constant VK_S3_COM_Y_hi = 18960525096180770843696696896872317269;
  
  uint256 private constant VK_COSET_SHIFT = 7;
  
  
  uint256 private constant VK_QCP_0_X_lo = 77445246684956721918903564062872450797382612585921682300559102052018369353519;
	uint256 private constant VK_QCP_0_X_hi = 10948127443397861085351157849778537474;
  uint256 private constant VK_QCP_0_Y_lo = 35293622030351734890994813117782576370845340837602130528703078960349760862335;
  uint256 private constant VK_QCP_0_Y_hi = 28193824207433103092963789565272458540;
  
  
  uint256 private constant VK_INDEX_COMMIT_API_0 = 3;
  uint256 private constant VK_NB_CUSTOM_GATES = 1;

  // ------------------------------------------------

  // size of the proof without call custom gate
  uint256 private constant FIXED_PROOF_SIZE = 0x420;

  // offset proof
  
	uint256 private constant PROOF_L_COM_X = 0x0;
  uint256 private constant PROOF_L_COM_Y = 0x30;
  uint256 private constant PROOF_R_COM_X = 0x60;
  uint256 private constant PROOF_R_COM_Y = 0x90;
  uint256 private constant PROOF_O_COM_X = 0xc0;
  uint256 private constant PROOF_O_COM_Y = 0xf0;

  // h = h_0 + x^{n+2}h_1 + x^{2(n+2)}h_2
  uint256 private constant PROOF_H_0_COM_X = 0x120;
  uint256 private constant PROOF_H_0_COM_Y = 0x150;
  uint256 private constant PROOF_H_1_COM_X = 0x180;
  uint256 private constant PROOF_H_1_COM_Y = 0x1b0;
  uint256 private constant PROOF_H_2_COM_X = 0x1e0;
  uint256 private constant PROOF_H_2_COM_Y = 0x210;

  // "evaluations of wire polynomials at zeta
  uint256 private constant PROOF_L_AT_ZETA = 0x240;
  uint256 private constant PROOF_R_AT_ZETA = 0x260;
  uint256 private constant PROOF_O_AT_ZETA = 0x280;

  // S1(zeta),S2(zeta)
  uint256 private constant PROOF_S1_AT_ZETA = 0x2a0; // SœÉ1(zeta)
  uint256 private constant PROOF_S2_AT_ZETA = 0x2c0; // SœÉ2(zeta)

  // [Z]
  uint256 private constant PROOF_GRAND_PRODUCT_COMMITMENT_X = 0x2e0;
  uint256 private constant PROOF_GRAND_PRODUCT_COMMITMENT_Y = 0x310;

  uint256 private constant PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA = 0x340; // z(w*zeta)

  // Folded proof for the opening of linearised poly, l, r, o, s_1, s_2, qcp
  uint256 private constant PROOF_BATCH_OPENING_AT_ZETA_X = 0x360;
  uint256 private constant PROOF_BATCH_OPENING_AT_ZETA_Y = 0x390;

  uint256 private constant PROOF_OPENING_AT_ZETA_OMEGA_X = 0x3c0;
  uint256 private constant PROOF_OPENING_AT_ZETA_OMEGA_Y = 0x3f0;

  uint256 private constant PROOF_QCP_AT_ZETA = 0x420;
  uint256 private constant PROOF_BSB_COMMITMENTS = 0x440;

  // -------- offset state

  // challenges to check the claimed quotient
  
  uint256 private constant STATE_ALPHA = 0x0;
  uint256 private constant STATE_BETA = 0x20;
  uint256 private constant STATE_GAMMA = 0x40;
  uint256 private constant STATE_ZETA = 0x60;
  uint256 private constant STATE_ALPHA_SQUARE_LAGRANGE_0 = 0x80;
  uint256 private constant STATE_FOLDED_H = 0xa0; // each coord is on 0x40 bytes, the top 0x10 bytes equal to 0
  uint256 private constant STATE_LINEARISED_POLYNOMIAL = 0x120;
  uint256 private constant STATE_OPENING_LINEARISED_POLYNOMIAL_ZETA = 0x1a0;
  uint256 private constant STATE_FOLDED_CLAIMED_VALUES = 0x1c0; // Folded proof for the opening of H, linearised poly, l, r, o, s_1, s_2, qcp
  uint256 private constant STATE_FOLDED_DIGESTS = 0x1e0; // linearised poly, l, r, o, s_1, s_2, qcp
  uint256 private constant STATE_PI = 0x260;
  uint256 private constant STATE_ZETA_POWER_N_MINUS_ONE = 0x280;
  uint256 private constant STATE_ZETA_POWER_N_PLUS_TWO = 0x2a0;
  uint256 private constant STATE_ZETA_POWER_N_PLUS_TWO_SQUARE = 0x2c0;
  uint256 private constant STATE_GAMMA_KZG = 0x2e0;
  uint256 private constant STATE_SUCCESS = 0x300;
  uint256 private constant STATE_CHECK_VAR = 0x320; // /!\ this slot is used for debugging only
  uint256 private constant STATE_LAST_MEM = 0x340;

  // -------- utils (for Fiat Shamir)
  uint256 private constant FS_ALPHA = 0x616C706861; // "alpha"
  uint256 private constant FS_BETA = 0x62657461; // "beta"
  uint256 private constant FS_GAMMA = 0x67616d6d61; // "gamma"
  uint256 private constant FS_ZETA = 0x7a657461; // "zeta"
  uint256 private constant FS_GAMMA_KZG = 0x67616d6d61; // "gamma"

  // -------- errors
  uint256 private constant ERROR_STRING_ID = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)

  
  // -------- utils (for hash_fr)
	uint256 private constant HASH_FR_BB = 340282366920938463463374607431768211456; // 2**128
	uint256 private constant HASH_FR_ZERO_UINT256 = 0;
	uint8 private constant HASH_FR_LEN_IN_BYTES = 48;
	uint8 private constant HASH_FR_SIZE_DOMAIN = 11;
	uint8 private constant HASH_FR_ONE = 1;
	uint8 private constant HASH_FR_TWO = 2;
  

  // -------- precompiles
  uint8 private constant SHA2 = 0x2;
  uint8 private constant MOD_EXP = 0x5;
  uint8 private constant EC_ADD = 0x6;
  uint8 private constant BLS12_MSM_G1 = 0x0c;
  uint8 private constant BLS12_PAIR = 0x0f;

  /// Verify a Plonk proof.
  /// Reverts if the proof or the public inputs are malformed.
  /// @param proof serialised plonk proof (using gnark's MarshalSolidity)
  /// @param public_inputs (must be reduced)
  /// @return success true if the proof passes false otherwise
  function Verify(bytes calldata proof, uint256[] calldata public_inputs) 
  public view returns(bool success) {

    assembly {

      let mem := mload(0x40)
      let freeMem := add(mem, STATE_LAST_MEM)

      // sanity checks
      check_number_of_public_inputs(public_inputs.length)
      check_inputs_size(public_inputs.length, public_inputs.offset)
      check_proof_size(proof.length)
      check_proof_openings_size(proof.offset)

    //   // compute the challenges
      let prev_challenge_non_reduced
      prev_challenge_non_reduced := derive_gamma(proof.offset, public_inputs.length, public_inputs.offset)
      prev_challenge_non_reduced := derive_beta(prev_challenge_non_reduced)
      prev_challenge_non_reduced := derive_alpha(proof.offset, prev_challenge_non_reduced)
      derive_zeta(proof.offset, prev_challenge_non_reduced)

      // evaluation of Z=X‚Åø-1 at Œ∂, we save this value
      let zeta := mload(add(mem, STATE_ZETA))
      let zeta_power_n_minus_one := addmod(pow(zeta, VK_DOMAIN_SIZE, freeMem), sub(R_MOD, 1), R_MOD)
      mstore(add(mem, STATE_ZETA_POWER_N_MINUS_ONE), zeta_power_n_minus_one)

      // public inputs contribution
      let l_pi := sum_pi_wo_api_commit(public_inputs.offset, public_inputs.length, freeMem)
      let l_pi_commit := sum_pi_commit(proof.offset, public_inputs.length, freeMem)
      l_pi := addmod(l_pi_commit, l_pi, R_MOD)
      mstore(add(mem, STATE_PI), l_pi)

      compute_alpha_square_lagrange_0()
      compute_zeta_powers_n_plus_two()
      compute_commitment_linearised_polynomial(proof.offset)
      compute_opening_linearised_polynomial(proof.offset)
      compute_gamma_kzg(proof.offset)
      fold_state(proof.offset)
      batch_verify_multi_points(proof.offset)
      success := mload(add(mem, STATE_SUCCESS))

    //   // Beginning errors -------------------------------------------------

      function error_nb_public_inputs() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x1d)
        mstore(add(ptError, 0x44), "wrong number of public inputs")
        revert(ptError, 0x64)
      }

      /// Called when an exponentiation mod r fails
      function error_mod_exp() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0xc)
        mstore(add(ptError, 0x44), "error mod exp")
        revert(ptError, 0x64)
      }

      /// Called when an operation on BLS12-381 fails
      /// @dev for instance when calling EcMul on a point not on BLS12-381.
      function error_ec_op() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x12)
        mstore(add(ptError, 0x44), "error ec operation")
        revert(ptError, 0x64)
      }

      /// Called when one of the public inputs is not reduced.
      function error_inputs_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x18)
        mstore(add(ptError, 0x44), "inputs are bigger than r")
        revert(ptError, 0x64)
      }

      /// Called when the size proof is not as expected
      /// @dev to avoid overflow attack for instance
      function error_proof_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x10)
        mstore(add(ptError, 0x44), "wrong proof size")
        revert(ptError, 0x64)
      }

      /// Called when one the openings is bigger than r
      /// The openings are the claimed evalutions of a polynomial
      /// in a Kzg proof.
      function error_proof_openings_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x16)
        mstore(add(ptError, 0x44), "openings bigger than r")
        revert(ptError, 0x64)
      }

      function error_pairing() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0xd)
        mstore(add(ptError, 0x44), "error pairing")
        revert(ptError, 0x64)
      }

      function error_verify() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0xc)
        mstore(add(ptError, 0x44), "error verify")
        revert(ptError, 0x64)
      }

      function error_random_generation() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x14)
        mstore(add(ptError, 0x44), "error random gen kzg")
        revert(ptError, 0x64)
      }
      // end errors -------------------------------------------------

      // Beginning checks -------------------------------------------------
      
      /// @param s actual number of public inputs
      function check_number_of_public_inputs(s) {
        if iszero(eq(s, VK_NB_PUBLIC_INPUTS)) {
          error_nb_public_inputs()
        }
      }
    
      /// Checks that the public inputs are < R_MOD.
      /// @param s number of public inputs
      /// @param p pointer to the public inputs array
      function check_inputs_size(s, p) {
        for {let i} lt(i, s) {i:=add(i,1)}
        {
          if gt(calldataload(p), R_MOD_MINUS_ONE) {
            error_inputs_size()
          }
          p := add(p, 0x20)
        }
      }

      /// Checks if the proof is of the correct size
      /// @param actual_proof_size size of the proof (not the expected size)
      function check_proof_size(actual_proof_size) {
        let expected_proof_size := add(FIXED_PROOF_SIZE, mul(VK_NB_CUSTOM_GATES,0x80))
        if iszero(eq(actual_proof_size, expected_proof_size)) {
         error_proof_size() 
        }
      }
    
      /// Checks if the multiple openings of the polynomials are < R_MOD.
      /// @param aproof pointer to the beginning of the proof
      /// @dev the 'a' prepending proof is to have a local name
      function check_proof_openings_size(aproof) {
        
        // PROOF_L_AT_ZETA
        let p := add(aproof, PROOF_L_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_R_AT_ZETA
        p := add(aproof, PROOF_R_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_O_AT_ZETA
        p := add(aproof, PROOF_O_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_S1_AT_ZETA
        p := add(aproof, PROOF_S1_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }
        
        // PROOF_S2_AT_ZETA
        p := add(aproof, PROOF_S2_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA
        p := add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_QCP_AT_ZETA
        
        p := add(aproof, PROOF_QCP_AT_ZETA)
        for {let i:=0} lt(i, VK_NB_CUSTOM_GATES) {i:=add(i,1)}
        {
          if gt(calldataload(p), R_MOD_MINUS_ONE) {
            error_proof_openings_size()
          }
          p := add(p, 0x20)
        }

      }
      // end checks -------------------------------------------------

    //   // Beginning challenges -------------------------------------------------

      /// Derive gamma as Sha256(<transcript>)
      /// @param aproof pointer to the proof
      /// @param nb_pi number of public inputs
      /// @param pi pointer to the array of public inputs
      /// @return the challenge gamma, not reduced
      /// @notice The transcript is the concatenation (in this order) of:
      /// * the word "gamma" in ascii, equal to [0x67,0x61,0x6d, 0x6d, 0x61] and encoded as a uint256.
      /// * the commitments to the permutation polynomials S1, S2, S3, where we concatenate the coordinates of those points
      /// * the commitments of Ql, Qr, Qm, Qo, Qk
      /// * the public inputs
      /// * the commitments of the wires related to the custom gates (commitments_wires_commit_api)
      /// * commitments to L, R, O (proof_<l,r,o>_com_<x,y>)
      /// The data described above is written starting at mPtr. "gamma" lies on 5 bytes,
      /// and is encoded as a uint256 number n. In basis b = 256, the number looks like this
      /// [0 0 0 .. 0x67 0x61 0x6d, 0x6d, 0x61]. The first non zero entry is at position 27=0x1b
      /// Gamma reduced (the actual challenge) is stored at add(state, state_gamma)
      function derive_gamma(aproof, nb_pi, pi)->gamma_not_reduced {
        
        let state := mload(0x40)
        let mPtr := add(state, STATE_LAST_MEM)

        
        mstore(add(mPtr, 0x10), VK_S1_COM_X_hi) 
        mstore(add(mPtr, 0x40), VK_S1_COM_Y_hi) 
        mstore(add(mPtr, 0x70), VK_S2_COM_X_hi) 
        mstore(add(mPtr, 0xa0), VK_S2_COM_Y_hi) 
        mstore(add(mPtr, 0xd0), VK_S3_COM_X_hi) 
        mstore(add(mPtr, 0x100), VK_S3_COM_Y_hi) 
        mstore(add(mPtr, 0x130), VK_QL_COM_X_hi) 
        mstore(add(mPtr, 0x160), VK_QL_COM_Y_hi) 
        mstore(add(mPtr, 0x190), VK_QR_COM_X_hi) 
        mstore(add(mPtr, 0x1c0), VK_QR_COM_Y_hi) 
        mstore(add(mPtr, 0x1f0), VK_QM_COM_X_hi) 
        mstore(add(mPtr, 0x220), VK_QM_COM_Y_hi) 
        mstore(add(mPtr, 0x250), VK_QO_COM_X_hi) 
        mstore(add(mPtr, 0x280), VK_QO_COM_Y_hi) 
        mstore(add(mPtr, 0x2b0), VK_QK_COM_X_hi) 
        mstore(add(mPtr, 0x2e0), VK_QK_COM_Y_hi) 
        
        mstore(add(mPtr, 0x310), VK_QCP_0_X_hi) 
        mstore(add(mPtr, 0x340), VK_QCP_0_Y_hi) 
        
        mstore(mPtr, FS_GAMMA) // "gamma"
        
        mstore(add(mPtr, 0x30), VK_S1_COM_X_lo) 
        mstore(add(mPtr, 0x60), VK_S1_COM_Y_lo) 
        mstore(add(mPtr, 0x90), VK_S2_COM_X_lo) 
        mstore(add(mPtr, 0xc0), VK_S2_COM_Y_lo) 
        mstore(add(mPtr, 0xf0), VK_S3_COM_X_lo) 
        mstore(add(mPtr, 0x120), VK_S3_COM_Y_lo) 
        mstore(add(mPtr, 0x150), VK_QL_COM_X_lo) 
        mstore(add(mPtr, 0x180), VK_QL_COM_Y_lo) 
        mstore(add(mPtr, 0x1b0), VK_QR_COM_X_lo) 
        mstore(add(mPtr, 0x1e0), VK_QR_COM_Y_lo) 
        mstore(add(mPtr, 0x210), VK_QM_COM_X_lo) 
        mstore(add(mPtr, 0x240), VK_QM_COM_Y_lo) 
        mstore(add(mPtr, 0x270), VK_QO_COM_X_lo) 
        mstore(add(mPtr, 0x2a0), VK_QO_COM_Y_lo) 
        mstore(add(mPtr, 0x2d0), VK_QK_COM_X_lo) 
        mstore(add(mPtr, 0x300), VK_QK_COM_Y_lo) 
        
        mstore(add(mPtr, 0x330), VK_QCP_0_X_lo) 
        mstore(add(mPtr, 0x360), VK_QCP_0_Y_lo) 
        
        // public inputs
        let _mPtr := add(mPtr, 0x380 )
        let size_pi_in_bytes := mul(nb_pi, 0x20)
        calldatacopy(_mPtr, pi, size_pi_in_bytes)
        _mPtr := add(_mPtr, size_pi_in_bytes)

        // commitments to l, r, o
        let size_commitments_lro_in_bytes := 0x120
        calldatacopy(_mPtr, aproof, size_commitments_lro_in_bytes)
        _mPtr := add(_mPtr, size_commitments_lro_in_bytes)

        // total size is :
        // sizegamma(=0x5) + 11*96(=0x420)
        // + nb_public_inputs*0x20
        // + nb_custom gates*0x60
        let size := add(0x425, size_pi_in_bytes)
        
        size := add(size, mul(VK_NB_CUSTOM_GATES, 0x60))
        let l_success := staticcall(gas(), SHA2, add(mPtr, 0x1b), size, mPtr, 0x20) //0x1b -> 000.."gamma"
        if iszero(l_success) {
          error_verify()
        }
        gamma_not_reduced := mload(mPtr)
        mstore(add(state, STATE_GAMMA), mod(gamma_not_reduced, R_MOD))
      }

      /// derive beta as Sha256<transcript>
      /// @param gamma_not_reduced the previous challenge (gamma) not reduced
      /// @return beta_not_reduced the next challenge, beta, not reduced
      /// @notice the transcript consists of the previous challenge only.
      /// The reduced version of beta is stored at add(state, state_beta)
      function derive_beta(gamma_not_reduced)->beta_not_reduced{
        
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        // beta
        mstore(mPtr, FS_BETA) // "beta"
        mstore(add(mPtr, 0x20), gamma_not_reduced)
        let l_success := staticcall(gas(), SHA2, add(mPtr, 0x1c), 0x24, mPtr, 0x20) //0x1b -> 000.."gamma"
        if iszero(l_success) {
          error_verify()
        }
        beta_not_reduced := mload(mPtr)
        mstore(add(state, STATE_BETA), mod(beta_not_reduced, R_MOD))
      }

      /// derive alpha as sha256<transcript>
      /// @param aproof pointer to the proof object
      /// @param beta_not_reduced the previous challenge (beta) not reduced
      /// @return alpha_not_reduced the next challenge, alpha, not reduced
      /// @notice the transcript consists of the previous challenge (beta)
      /// not reduced, the commitments to the wires associated to the QCP_i,
      /// and the commitment to the grand product polynomial 
      function derive_alpha(aproof, beta_not_reduced)->alpha_not_reduced {
        
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)
        let full_size := 0x85 // "alpha" || previous challenge || grand product commitment

        // alpha
        mstore(mPtr, FS_ALPHA) // "alpha"
        let _mPtr := add(mPtr, 0x20)
        mstore(_mPtr, beta_not_reduced)
        _mPtr := add(_mPtr, 0x20)
        
        // Bsb22Commitments
        let proof_bsb_commitments := add(aproof, PROOF_BSB_COMMITMENTS)
        let size_bsb_commitments := mul(0x60, VK_NB_CUSTOM_GATES)
        calldatacopy(_mPtr, proof_bsb_commitments, size_bsb_commitments)
        _mPtr := add(_mPtr, size_bsb_commitments)
        full_size := add(full_size, size_bsb_commitments)
        
        // [Z], the commitment to the grand product polynomial
        calldatacopy(_mPtr, add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X), 0x60)
        let l_success := staticcall(gas(), SHA2, add(mPtr, 0x1b), full_size, mPtr, 0x20)
        if iszero(l_success) {
          error_verify()
        }

        alpha_not_reduced := mload(mPtr)
        mstore(add(state, STATE_ALPHA), mod(alpha_not_reduced, R_MOD))
      }

      /// derive zeta as sha256<transcript>
      /// @param aproof pointer to the proof object
      /// @param alpha_not_reduced the previous challenge (alpha) not reduced
      /// The transcript consists of the previous challenge and the commitment to
      /// the quotient polynomial h.
      function derive_zeta(aproof, alpha_not_reduced) {
        
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        // zeta
        mstore(mPtr, FS_ZETA) // "zeta"
        mstore(add(mPtr, 0x20), alpha_not_reduced)
        calldatacopy(add(mPtr, 0x40), add(aproof, PROOF_H_0_COM_X), 0x120)
        let l_success := staticcall(gas(), SHA2, add(mPtr, 0x1c), 0x144, mPtr, 0x20)
        if iszero(l_success) {
          error_verify()
        }
        let zeta_not_reduced := mload(mPtr)
        mstore(add(state, STATE_ZETA), mod(zeta_not_reduced, R_MOD))
      }
      // END challenges -------------------------------------------------

    //   // BEGINNING compute_pi -------------------------------------------------

      /// sum_pi_wo_api_commit computes the public inputs contributions,
      /// except for the public inputs coming from the custom gate
      /// @param ins pointer to the public inputs
      /// @param n number of public inputs
      /// @param mPtr free memory
      /// @return pi_wo_commit public inputs contribution (except the public inputs coming from the custom gate)
      function sum_pi_wo_api_commit(ins, n, mPtr)->pi_wo_commit {
        
        let state := mload(0x40)
        let z := mload(add(state, STATE_ZETA))
        let zpnmo := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))

        let li := mPtr
        batch_compute_lagranges_at_z(z, zpnmo, n, li)

        let tmp := 0
        for {let i:=0} lt(i,n) {i:=add(i,1)}
        {
          tmp := mulmod(mload(li), calldataload(ins), R_MOD)
          pi_wo_commit := addmod(pi_wo_commit, tmp, R_MOD)
          li := add(li, 0x20)
          ins := add(ins, 0x20)
        }
        
      }

      /// batch_compute_lagranges_at_z computes [L_0(z), .., L_{n-1}(z)]
      /// @param z point at which the Lagranges are evaluated
      /// @param zpnmo Œ∂‚Åø-1
      /// @param n_pub number of public inputs (number of Lagranges to compute)
      /// @param mPtr pointer to which the results are stored
      function batch_compute_lagranges_at_z(z, zpnmo, n_pub, mPtr) {

        let zn := mulmod(zpnmo, VK_INV_DOMAIN_SIZE, R_MOD) // 1/n * (Œ∂‚Åø - 1)
        
        let _w := 1
        let _mPtr := mPtr
        for {let i:=0} lt(i,n_pub) {i:=add(i,1)}
        {
          mstore(_mPtr, addmod(z,sub(R_MOD, _w), R_MOD))
          _w := mulmod(_w, VK_OMEGA, R_MOD)
          _mPtr := add(_mPtr, 0x20)
        }
        batch_invert(mPtr, n_pub, _mPtr)
        _mPtr := mPtr
        _w := 1
        for {let i:=0} lt(i,n_pub) {i:=add(i,1)}
        {
          mstore(_mPtr, mulmod(mulmod(mload(_mPtr), zn , R_MOD), _w, R_MOD))
          _mPtr := add(_mPtr, 0x20)
          _w := mulmod(_w, VK_OMEGA, R_MOD)
        }
      } 

      /// @notice Montgomery trick for batch inversion mod R_MOD
      /// @param ins pointer to the data to batch invert
      /// @param number of elements to batch invert
      /// @param mPtr free memory
      function batch_invert(ins, nb_ins, mPtr) {
        mstore(mPtr, 1)
        let offset := 0
        for {let i:=0} lt(i, nb_ins) {i:=add(i,1)}
        {
          let prev := mload(add(mPtr, offset))
          let cur := mload(add(ins, offset))
          cur := mulmod(prev, cur, R_MOD)
          offset := add(offset, 0x20)
          mstore(add(mPtr, offset), cur)
        }
        ins := add(ins, sub(offset, 0x20))
        mPtr := add(mPtr, offset)
        let inv := pow(mload(mPtr), sub(R_MOD,2), add(mPtr, 0x20))
        for {let i:=0} lt(i, nb_ins) {i:=add(i,1)}
        {
          mPtr := sub(mPtr, 0x20)
          let tmp := mload(ins)
          let cur := mulmod(inv, mload(mPtr), R_MOD)
          mstore(ins, cur)
          inv := mulmod(inv, tmp, R_MOD)
          ins := sub(ins, 0x20)
        }
      }

      
      /// Public inputs (the ones coming from the custom gate) contribution
      /// @param aproof pointer to the proof
      /// @param nb_public_inputs number of public inputs
      /// @param mPtr pointer to free memory
      /// @return pi_commit custom gate public inputs contribution
      function sum_pi_commit(aproof, nb_public_inputs, mPtr)->pi_commit {

        let state := mload(0x40)
        let z := mload(add(state, STATE_ZETA))
        let zpnmo := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))

        let p := add(aproof, PROOF_BSB_COMMITMENTS)

        let h_fr, ith_lagrange
       
        
        h_fr := hash_fr(p, mPtr)
        ith_lagrange := compute_ith_lagrange_at_z(z, zpnmo, add(nb_public_inputs, VK_INDEX_COMMIT_API_0), mPtr)
        pi_commit := addmod(pi_commit, mulmod(h_fr, ith_lagrange, R_MOD), R_MOD)
        

      }

      /// Computes L_i(zeta) =  œâ‚Å±/n * (Œ∂‚Åø-1)/(Œ∂-œâ‚Å±) where:
      /// @param z zeta
      /// @param zpmno Œ∂‚Åø-1
      /// @param i i-th lagrange
      /// @param mPtr free memory
      /// @return res = œâ‚Å±/n * (Œ∂‚Åø-1)/(Œ∂-œâ‚Å±) 
      function compute_ith_lagrange_at_z(z, zpnmo, i, mPtr)->res {

        let w := pow(VK_OMEGA, i, mPtr) // w**i
        i := addmod(z, sub(R_MOD, w), R_MOD) // z-w**i
        w := mulmod(w, VK_INV_DOMAIN_SIZE, R_MOD) // w**i/n
        i := pow(i, sub(R_MOD,2), mPtr) // (z-w**i)**-1
        w := mulmod(w, i, R_MOD) // w**i/n*(z-w)**-1
        res := mulmod(w, zpnmo, R_MOD)
      
      }

      /// @dev https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-06#section-5.2
      /// @param p pointer to a marshalled point on BLS12-381(ùîΩ_p)
      /// @param mPtr free memory
      /// @return res an element mod R_MOD
      function hash_fr(p, mPtr)->res {

        // [0x00, .. , 0x00 || x, y, || 0, 48, 0, dst, HASH_FR_SIZE_DOMAIN]
        // <-  64 bytes  ->  <-64b -> <-       1 bytes each     ->

        // [0x00, .., 0x00] 64 bytes of zero
        mstore(mPtr, HASH_FR_ZERO_UINT256)
        mstore(add(mPtr, 0x20), HASH_FR_ZERO_UINT256)
    
        // msg =  p , both on 96 bytes
        calldatacopy(add(mPtr, 0x40), p, 0x60)

        // 0 || 48 || 0 all on 1 byte
        mstore8(add(mPtr, 0xa0), 0)
        mstore8(add(mPtr, 0xa1), HASH_FR_LEN_IN_BYTES)
        mstore8(add(mPtr, 0xa2), 0)

        // "BSB22-Plonk" = [42, 53, 42, 32, 32, 2d, 50, 6c, 6f, 6e, 6b,]
        mstore8(add(mPtr, 0xa3), 0x42)
        mstore8(add(mPtr, 0xa4), 0x53)
        mstore8(add(mPtr, 0xa5), 0x42)
        mstore8(add(mPtr, 0xa6), 0x32)
        mstore8(add(mPtr, 0xa7), 0x32)
        mstore8(add(mPtr, 0xa8), 0x2d)
        mstore8(add(mPtr, 0xa9), 0x50)
        mstore8(add(mPtr, 0xaa), 0x6c)
        mstore8(add(mPtr, 0xab), 0x6f)
        mstore8(add(mPtr, 0xac), 0x6e)
        mstore8(add(mPtr, 0xad), 0x6b)

        // size domain
        mstore8(add(mPtr, 0xae), HASH_FR_SIZE_DOMAIN)

        let l_success := staticcall(gas(), SHA2, mPtr, 0xaf, mPtr, 0x20)
        if iszero(l_success) {
          error_verify()
        }

        let b0 := mload(mPtr)

        // [b0         || one || dst || HASH_FR_SIZE_DOMAIN]
        // <-64bytes ->  <-    1 byte each      ->
        mstore8(add(mPtr, 0x20), HASH_FR_ONE) // 1
        
        mstore8(add(mPtr, 0x21), 0x42) // dst
        mstore8(add(mPtr, 0x22), 0x53)
        mstore8(add(mPtr, 0x23), 0x42)
        mstore8(add(mPtr, 0x24), 0x32)
        mstore8(add(mPtr, 0x25), 0x32)
        mstore8(add(mPtr, 0x26), 0x2d)
        mstore8(add(mPtr, 0x27), 0x50)
        mstore8(add(mPtr, 0x28), 0x6c)
        mstore8(add(mPtr, 0x29), 0x6f)
        mstore8(add(mPtr, 0x2a), 0x6e)
        mstore8(add(mPtr, 0x2b), 0x6b)

        mstore8(add(mPtr, 0x2c), HASH_FR_SIZE_DOMAIN) // size domain
        l_success := staticcall(gas(), SHA2, mPtr, 0x2d, mPtr, 0x20)
        if iszero(l_success) {
          error_verify()
        }

        // b1 is located at mPtr. We store b2 at add(mPtr, 0x20)

        // [b0^b1      || two || dst || HASH_FR_SIZE_DOMAIN]
        // <-64bytes ->  <-    1 byte each      ->
        mstore(add(mPtr, 0x20), xor(mload(mPtr), b0))
        mstore8(add(mPtr, 0x40), HASH_FR_TWO)

        mstore8(add(mPtr, 0x41), 0x42) // dst
        mstore8(add(mPtr, 0x42), 0x53)
        mstore8(add(mPtr, 0x43), 0x42)
        mstore8(add(mPtr, 0x44), 0x32)
        mstore8(add(mPtr, 0x45), 0x32)
        mstore8(add(mPtr, 0x46), 0x2d)
        mstore8(add(mPtr, 0x47), 0x50)
        mstore8(add(mPtr, 0x48), 0x6c)
        mstore8(add(mPtr, 0x49), 0x6f)
        mstore8(add(mPtr, 0x4a), 0x6e)
        mstore8(add(mPtr, 0x4b), 0x6b)

        mstore8(add(mPtr, 0x4c), HASH_FR_SIZE_DOMAIN) // size domain

        let offset := add(mPtr, 0x20)
        l_success := staticcall(gas(), SHA2, offset, 0x2d, offset, 0x20)
        if iszero(l_success) {
          error_verify()
        }

        // at this point we have mPtr = [ b1 || b2] where b1 is on 32byes and b2 in 16bytes.
        // we interpret it as a big integer mod r in big endian (similar to regular decimal notation)
        // the result is then 2**(8*16)*mPtr[:32] + mPtr[32:48]
        res := mulmod(mload(mPtr), HASH_FR_BB, R_MOD) // <- res = 2**128 * mPtr[:32]
        let b1 := shr(128, mload(add(mPtr, 0x20))) // b1 <- [0, 0, .., 0 ||  b2[:16] ]
        res := addmod(res, b1, R_MOD)

      }
      
      // END compute_pi -------------------------------------------------

      /// @notice compute Œ±¬≤ * 1/n * (Œ∂{n}-1)/(Œ∂ - 1) where
      /// *  Œ± = challenge derived in derive_gamma_beta_alpha_zeta
      /// * n = vk_domain_size
      /// * œâ = vk_omega (generator of the multiplicative cyclic group of order n in (‚Ñ§/r‚Ñ§)*)
      /// * Œ∂ = zeta (challenge derived with Fiat Shamir)
      function compute_alpha_square_lagrange_0() {   
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        let res := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))
        let den := addmod(mload(add(state, STATE_ZETA)), sub(R_MOD, 1), R_MOD)
        den := pow(den, sub(R_MOD, 2), mPtr)
        den := mulmod(den, VK_INV_DOMAIN_SIZE, R_MOD)
        res := mulmod(den, res, R_MOD)

        let l_alpha := mload(add(state, STATE_ALPHA))
        res := mulmod(res, l_alpha, R_MOD)
        res := mulmod(res, l_alpha, R_MOD)
        mstore(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0), res)
      }

      /// @notice follows alg. p.13 of https://eprint.iacr.org/2019/953.pdf
      /// with t‚ÇÅ = t‚ÇÇ = 1, and the proofs are ([digest] + [quotient] +purported evaluation):
      /// * [state_folded_state_digests], [proof_batch_opening_at_zeta_x], state_folded_evals
      /// * [proof_grand_product_commitment], [proof_opening_at_zeta_omega_x], [proof_grand_product_at_zeta_omega]
      /// @param aproof pointer to the proof
      function batch_verify_multi_points(aproof) {
        
        let state := mload(0x40)
        let mPtr := add(state, STATE_LAST_MEM)

        // derive a random number. As there is no random generator, we
        // do an FS like challenge derivation, depending on both digests and
        // Œ∂ to ensure that the prover cannot control the random number.
        // Note: adding the other point Œ∂œâ is not needed, as œâ is known beforehand.
        
        mcopy(mPtr, add(state, STATE_FOLDED_DIGESTS), 0x80)
        calldatacopy(add(mPtr, 0x60), add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X), 0x60)
        calldatacopy(add(mPtr, 0xc0), add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X), 0x60)
        calldatacopy(add(mPtr, 0x120), add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X), 0x60)
        mstore(add(mPtr, 0x180), mload(add(state, STATE_ZETA)))
        mstore(add(mPtr, 0x1a0), mload(add(state, STATE_GAMMA_KZG)))
        let random := staticcall(gas(), SHA2, mPtr, 448, mPtr, 0x20)
        if iszero(random){
          error_random_generation()
        }
        random := mod(mload(mPtr), R_MOD)

        let folded_evals := add(state, STATE_FOLDED_CLAIMED_VALUES)
        fr_acc_mul_calldata(folded_evals, add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA), random)

        let folded_digests := mPtr
        mcopy(folded_digests, add(state, STATE_FOLDED_DIGESTS), 0x80)
        mstore(add(folded_digests, 0x80), 1)
        store_point_calldata(add(folded_digests, 0xa0), add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X))
        mstore(add(folded_digests, 0x120), random)
        store_point(add(folded_digests, 0x140), G1_SRS_X_hi, G1_SRS_X_lo, G1_SRS_Y_hi, G1_SRS_Y_lo)
        mstore(add(folded_digests, 0x1c0), sub(R_MOD, mload(folded_evals)))
        store_point_calldata(add(folded_digests, 0x1e0), add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X))
        mstore(add(folded_digests, 0x260), mload(add(state, STATE_ZETA)))
        store_point_calldata(add(folded_digests, 0x280), add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X))
        let zeta_omega := mulmod(mload(add(state, STATE_ZETA)), VK_OMEGA, R_MOD)
        mstore(add(folded_digests, 0x300), mulmod(random, zeta_omega, R_MOD))
        let l_success := staticcall(gas(), BLS12_MSM_G1, folded_digests, 0x320, folded_digests, 0x80)
        if iszero(l_success){
          error_ec_op()
        }

        let folded_quotients := add(mPtr, 0x180)
        store_point_calldata(folded_quotients, add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X))
        mstore(add(folded_quotients, 0x80), sub(R_MOD, 1))
        store_point_calldata(add(folded_quotients, 0xa0), add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X))
        mstore(add(folded_quotients, 0x120), sub(R_MOD, random))
        l_success := staticcall(gas(), BLS12_MSM_G1, folded_quotients, 0x140, folded_quotients, 0x80)
        if iszero(l_success){
          error_ec_op()
        }
      
        store_point(add(mPtr,  0x80), G2_SRS_0_X_0_hi, G2_SRS_0_X_0_lo, G2_SRS_0_X_1_hi, G2_SRS_0_X_1_lo)
        store_point(add(mPtr, 0x100), G2_SRS_0_Y_0_hi, G2_SRS_0_Y_0_lo, G2_SRS_0_Y_1_hi, G2_SRS_0_Y_1_lo)
        store_point(add(mPtr, 0x200), G2_SRS_1_X_0_hi, G2_SRS_1_X_0_lo, G2_SRS_1_X_1_hi, G2_SRS_1_X_1_lo)
        store_point(add(mPtr, 0x280), G2_SRS_1_Y_0_hi, G2_SRS_1_Y_0_lo, G2_SRS_1_Y_1_hi, G2_SRS_1_Y_1_lo)
        l_success := staticcall(gas(), BLS12_PAIR, mPtr, 0x300, mPtr, 0x20)
        if iszero(l_success) {
          error_pairing()
        }
        mstore(add(state, STATE_SUCCESS), mload(mPtr))
      }

      /// @notice Fold the opening proofs at Œ∂:
      /// * at state+STATE_FOLDED_DIGEST we store: [Linearised_polynomial]+Œ≥[L] + Œ≥¬≤[R] + Œ≥¬≥[O] + Œ≥‚Å¥[S‚ÇÅ] +Œ≥‚Åµ[S‚ÇÇ] + ‚àë·µ¢Œ≥‚Åµ‚Å∫‚Å±[Pi_{i}]
      /// * at state+STATE_FOLDED_CLAIMED_VALUE we store: Linearised_polynomial(Œ∂)+Œ≥L(Œ∂) + Œ≥¬≤R(Œ∂)+ Œ≥¬≥O(Œ∂) + Œ≥‚Å¥S‚ÇÅ(Œ∂) +Œ≥‚ÅµS‚ÇÇ(Œ∂) + ‚àë·µ¢Œ≥‚Åµ‚Å∫‚Å±Pi_{i}(Œ∂)
      /// @param aproof pointer to the proof
      /// acc_gamma stores the Œ≥‚Å±
      function fold_state(aproof) {

        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        let l_gamma_kzg := mload(add(state, STATE_GAMMA_KZG))
        let acc_gamma := l_gamma_kzg

        
        mstore(add(state, STATE_FOLDED_CLAIMED_VALUES), mload(add(state, STATE_OPENING_LINEARISED_POLYNOMIAL_ZETA)))
        mcopy(mPtr, add(state, STATE_LINEARISED_POLYNOMIAL), 0x80)
        mstore(add(mPtr, 0x80), 1)

        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_L_AT_ZETA), acc_gamma)
        store_point_calldata(add(mPtr, 0xa0), add(aproof, PROOF_L_COM_X))
        mstore(add(mPtr, 0x120), acc_gamma)
        
        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_R_AT_ZETA), acc_gamma)
        store_point_calldata(add(mPtr, 0x140), add(aproof, PROOF_R_COM_X))
        mstore(add(mPtr, 0x1c0), acc_gamma)

        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_O_AT_ZETA), acc_gamma)
        store_point_calldata(add(mPtr, 0x1e0), add(aproof, PROOF_O_COM_X))
        mstore(add(mPtr, 0x260), acc_gamma)

        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_S1_AT_ZETA), acc_gamma)
        store_point(add(mPtr, 0x280), VK_S1_COM_X_hi, VK_S1_COM_X_lo, VK_S1_COM_Y_hi, VK_S1_COM_Y_lo)
        mstore(add(mPtr, 0x300), acc_gamma)

        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_S2_AT_ZETA), acc_gamma)
        store_point(add(mPtr, 0x320), VK_S2_COM_X_hi, VK_S2_COM_X_lo, VK_S2_COM_Y_hi, VK_S2_COM_Y_lo)
        mstore(add(mPtr, 0x3a0), acc_gamma)

        
        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, add(PROOF_QCP_AT_ZETA, 0x0)), acc_gamma)
        store_point(add(mPtr, 0x3c0), VK_QCP_0_X_hi, VK_QCP_0_X_lo, VK_QCP_0_Y_hi, VK_QCP_0_Y_lo)
        mstore(add(mPtr, 0x440), acc_gamma)
        
        
        let l_success := staticcall(gas(), BLS12_MSM_G1, mPtr, 0x460, add(state, STATE_FOLDED_DIGESTS), 0x80)
        if iszero(l_success){
          error_ec_op()
        }
        
      }

      /// @notice generate the challenge (using Fiat Shamir) to fold the opening proofs
      /// at Œ∂.
      /// The process for deriving Œ≥ is the same as in derive_gamma but this time the inputs are
      /// in this order (the [] means it's a commitment):
      /// * Œ∂
      /// * [Linearised polynomial]
      /// * [L], [R], [O]
      /// * [S‚ÇÅ] [S‚ÇÇ]
      /// * [Pi_{i}] (wires associated to custom gates)
      /// Then there are the purported evaluations of the previous committed polynomials:
      /// * Linearised_polynomial(Œ∂)
      /// * L(Œ∂), R(Œ∂), O(Œ∂), S‚ÇÅ(Œ∂), S‚ÇÇ(Œ∂)
      /// * Pi_{i}(Œ∂)
      /// * Z(Œ∂œâ)
      /// @param aproof pointer to the proof
      function compute_gamma_kzg(aproof) {

        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        
        mstore(add(mPtr, 0x1b0), VK_S1_COM_X_hi)
        mstore(add(mPtr, 0x1e0), VK_S1_COM_Y_hi)
        mstore(add(mPtr, 0x210), VK_S2_COM_X_hi)
        mstore(add(mPtr, 0x240), VK_S2_COM_Y_hi)
        mstore(add(mPtr, 0x270), VK_QCP_0_X_hi)
        mstore(add(mPtr, 0x2a0), VK_QCP_0_Y_hi)
        
        mstore(add(mPtr, 0x1d0), VK_S1_COM_X_lo)
        mstore(add(mPtr, 0x200), VK_S1_COM_Y_lo)
        mstore(add(mPtr, 0x230), VK_S2_COM_X_lo)
        mstore(add(mPtr, 0x260), VK_S2_COM_Y_lo)
        mstore(add(mPtr, 0x290), VK_QCP_0_X_lo)
        mstore(add(mPtr, 0x2c0), VK_QCP_0_Y_lo)
        

        
        mstore(mPtr, FS_GAMMA_KZG) // "gamma" 
        mstore(add(mPtr, 0x20), mload(add(state, STATE_ZETA)))
        mcopy(add(mPtr, 0x40), add(state, add(STATE_LINEARISED_POLYNOMIAL, 0x10)), 0x30)
        mcopy(add(mPtr, 0x70), add(state, add(STATE_LINEARISED_POLYNOMIAL, 0x50)), 0x30)
        calldatacopy(add(mPtr, 0xa0), add(aproof, PROOF_L_COM_X), 0x120)
        
        
        mstore(add(mPtr, 0x2e0), mload(add(state, STATE_OPENING_LINEARISED_POLYNOMIAL_ZETA))) 
        mstore(add(mPtr, 0x300), calldataload(add(aproof, PROOF_L_AT_ZETA)))
        mstore(add(mPtr, 0x320), calldataload(add(aproof, PROOF_R_AT_ZETA)))
        mstore(add(mPtr, 0x340), calldataload(add(aproof, PROOF_O_AT_ZETA)))
        mstore(add(mPtr, 0x360), calldataload(add(aproof, PROOF_S1_AT_ZETA)))
        mstore(add(mPtr, 0x380), calldataload(add(aproof, PROOF_S2_AT_ZETA)))
        let _poqaz := add(aproof, PROOF_QCP_AT_ZETA)
        calldatacopy(add(mPtr, 0x3a0), _poqaz, mul(VK_NB_CUSTOM_GATES, 0x20))
        
        mstore(add(mPtr, 0x3c0), calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)))

        let start_input := 0x1b // 00.."gamma"
        
        let check_staticcall := staticcall(gas(), SHA2, add(mPtr,start_input), 0x3c5, add(state, STATE_GAMMA_KZG), 0x20)
        if iszero(check_staticcall) {
          error_verify()
        }
        mstore(add(state, STATE_GAMMA_KZG), mod(mload(add(state, STATE_GAMMA_KZG)), R_MOD))
      }

      /// @notice Compute the commitment to the linearized polynomial equal to
      ///	L(Œ∂)[Q‚Çó]+r(Œ∂)[Q·µ£]+R(Œ∂)L(Œ∂)[Q‚Çò]+O(Œ∂)[Q‚Çí]+[Q‚Çñ]+Œ£·µ¢qc'·µ¢(Œ∂)[BsbCommitment·µ¢] +
      ///	Œ±*( Z(ŒºŒ∂)(L(Œ∂)+Œ≤*S‚ÇÅ(Œ∂)+Œ≥)*(R(Œ∂)+Œ≤*S‚ÇÇ(Œ∂)+Œ≥)[S‚ÇÉ]-[Z](L(Œ∂)+Œ≤*id_{1}(Œ∂)+Œ≥)*(R(Œ∂)+Œ≤*id_{2}(Œ∂)+Œ≥)*(O(Œ∂)+Œ≤*id_{3}(Œ∂)+Œ≥) ) +
      ///	Œ±¬≤*L‚ÇÅ(Œ∂)[Z] - Z_{H}(Œ∂)*(([H‚ÇÄ] + Œ∂·µê‚Å∫¬≤*[H‚ÇÅ] + Œ∂¬≤‚ÅΩ·µê‚Å∫¬≤‚Åæ*[H‚ÇÇ])
      /// where
      /// * id_1 = id, id_2 = vk_coset_shift*id, id_3 = vk_coset_shift^{2}*id
      /// * the [] means that it's a commitment (i.e. a point on BLS12-381(F_p))
      /// * Z_{H}(Œ∂) = Œ∂^n-1
      /// @param aproof pointer to the proof
      function compute_commitment_linearised_polynomial(aproof) {
        
        let state := mload(0x40)
        let l_beta := mload(add(state, STATE_BETA))
        let l_gamma := mload(add(state, STATE_GAMMA))
        let l_zeta := mload(add(state, STATE_ZETA))
        let l_alpha := mload(add(state, STATE_ALPHA))

        let u := mulmod(calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)), l_beta, R_MOD)
        let v := mulmod(l_beta, calldataload(add(aproof, PROOF_S1_AT_ZETA)), R_MOD)
        v := addmod(v, calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD)
        v := addmod(v, l_gamma, R_MOD)

        let w := mulmod(l_beta, calldataload(add(aproof, PROOF_S2_AT_ZETA)), R_MOD)
        w := addmod(w, calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)
        w := addmod(w, l_gamma, R_MOD)

        let s1 := mulmod(u, v, R_MOD)
        s1 := mulmod(s1, w, R_MOD)
        s1 := mulmod(s1, l_alpha, R_MOD)

        let coset_square := mulmod(VK_COSET_SHIFT, VK_COSET_SHIFT, R_MOD)
        let betazeta := mulmod(l_beta, l_zeta, R_MOD)
        u := addmod(betazeta, calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD)
        u := addmod(u, l_gamma, R_MOD)

        v := mulmod(betazeta, VK_COSET_SHIFT, R_MOD)
        v := addmod(v, calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)
        v := addmod(v, l_gamma, R_MOD)

        w := mulmod(betazeta, coset_square, R_MOD)
        w := addmod(w, calldataload(add(aproof, PROOF_O_AT_ZETA)), R_MOD)
        w := addmod(w, l_gamma, R_MOD)

        let coeff_z := mulmod(u, v, R_MOD)
        coeff_z := mulmod(coeff_z, w, R_MOD)
        coeff_z := sub(R_MOD, coeff_z)
        coeff_z := mulmod(coeff_z, l_alpha, R_MOD)
        mstore(add(state, STATE_CHECK_VAR), coeff_z)
        coeff_z := addmod(coeff_z, mload(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0)), R_MOD)

        // at this stage:
        // * s‚ÇÅ = Œ±*Z(ŒºŒ∂)(l(Œ∂)+Œ≤*s‚ÇÅ(Œ∂)+Œ≥)*(r(Œ∂)+Œ≤*s‚ÇÇ(Œ∂)+Œ≥)*Œ≤
        // * s‚ÇÇ = -Œ±*(l(Œ∂)+Œ≤*Œ∂+Œ≥)*(r(Œ∂)+Œ≤*u*Œ∂+Œ≥)*(o(Œ∂)+Œ≤*u¬≤*Œ∂+Œ≥) + Œ±¬≤*L‚ÇÅ(Œ∂)

        compute_commitment_linearised_polynomial_ec(aproof, s1, coeff_z)
      }

      function compute_commitment_linearised_polynomial_ec(aproof, s1, coeff_z) {
          
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)
        
        store_point(add(mPtr, 0x0), VK_QL_COM_X_hi, VK_QL_COM_X_lo, VK_QL_COM_Y_hi, VK_QL_COM_Y_lo)
        store_point(add(mPtr, 0xa0), VK_QR_COM_X_hi, VK_QR_COM_X_lo, VK_QR_COM_Y_hi, VK_QR_COM_Y_lo)
        store_point(add(mPtr, 0x140), VK_QM_COM_X_hi, VK_QM_COM_X_lo, VK_QM_COM_Y_hi, VK_QM_COM_Y_lo)
        store_point(add(mPtr, 0x1e0), VK_QO_COM_X_hi, VK_QO_COM_X_lo, VK_QO_COM_Y_hi, VK_QO_COM_Y_lo)
        store_point(add(mPtr, 0x280), VK_QK_COM_X_hi, VK_QK_COM_X_lo, VK_QK_COM_Y_hi, VK_QK_COM_Y_lo)
        store_point(add(mPtr, 0x320), VK_S3_COM_X_hi, VK_S3_COM_X_lo, VK_S3_COM_Y_hi, VK_S3_COM_Y_lo)
        store_point_calldata(add(mPtr, 0x3c0), add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X))
        store_point_calldata(add(mPtr, 0x460), add(aproof, PROOF_H_0_COM_X))
        store_point_calldata(add(mPtr, 0x500), add(aproof, PROOF_H_1_COM_X))
        store_point_calldata(add(mPtr, 0x5a0), add(aproof, PROOF_H_2_COM_X))
        store_point_calldata(add(mPtr, 0x640), add(aproof, add(PROOF_BSB_COMMITMENTS, 0x0)))

        let l := calldataload(add(aproof, PROOF_L_AT_ZETA))
        let r := calldataload(add(aproof, PROOF_R_AT_ZETA))
        let rl := mulmod(l, r, R_MOD)
        let o := calldataload(add(aproof, PROOF_O_AT_ZETA))
        let h_zeta := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))
        h_zeta := sub(R_MOD, h_zeta)
        
        mstore(add(mPtr, 0x80), l)
        mstore(add(mPtr, 0x120), r)
        mstore(add(mPtr, 0x1c0), rl)
        mstore(add(mPtr, 0x260), o)
        mstore(add(mPtr, 0x300), 1)
        mstore(add(mPtr, 0x3a0), s1)
        mstore(add(mPtr, 0x440), coeff_z)
        mstore(add(mPtr, 0x4e0), h_zeta)
        mstore(add(mPtr, 0x580), mload(add(state, STATE_ZETA_POWER_N_PLUS_TWO)))
        mstore(add(mPtr, 0x620), mload(add(state, STATE_ZETA_POWER_N_PLUS_TWO_SQUARE)))
        calldatacopy(add(mPtr, 0x6c0), add(aproof, add(PROOF_QCP_AT_ZETA, 0x0)), 0x20)
        
        let l_success := staticcall(gas(), BLS12_MSM_G1, mPtr, 0x6e0, add(state, STATE_LINEARISED_POLYNOMIAL), 0x80)
        if iszero(l_success){
          error_ec_op()
        }

      }

      /// @notice stores a point at dst, from src. The point in src is stored
      /// as [x || y] where x and y are on 0x30 bytes, and in dst the point is stored
      /// as [x || y] where x and y are on 0x40 bytes, the top 0x10 bytes being 0.
      /// @param dst destination pointer storing the new point
      /// @param src source pointer (calldata)
      function store_point_calldata(dst, src) {
        mstore(dst, 0x00)
        calldatacopy(add(dst, 0x10), src, 0x30)
        mstore(add(dst, 0x40), 0x00)
        calldatacopy(add(dst, 0x50), add(src, 0x30), 0x30)
      }
      
      /// @param dst destination pointer storing the new point
      /// @param x_hi MSB of x
      /// @param x_lo LSB of x
      /// @param y_hi MSB of y
      /// @param y_hi LSB of y
      function store_point(dst, x_hi, x_lo, y_hi, y_lo) {
        mstore(dst, x_hi)
        mstore(add(dst, 0x20), x_lo)
        mstore(add(dst, 0x40), y_hi)
        mstore(add(dst, 0x60), y_lo)
      }

      /// @notice computes Œ∂‚Åø‚Å∫¬≤ and Œ∂¬≤‚ÅΩ‚Åø‚Å∫¬≤‚Åæ
      function compute_zeta_powers_n_plus_two() {
        let state := mload(0x40)
        let n_plus_two := add(VK_DOMAIN_SIZE, 2)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)
        let zeta_power_n_plus_two := pow(mload(add(state, STATE_ZETA)), n_plus_two, mPtr)
        let zeta_power_n_plus_two_square := mulmod(zeta_power_n_plus_two, zeta_power_n_plus_two, R_MOD)
        let h_zeta := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))
        h_zeta := sub(R_MOD, h_zeta)
        zeta_power_n_plus_two := mulmod(zeta_power_n_plus_two, h_zeta, R_MOD)
        zeta_power_n_plus_two_square := mulmod(zeta_power_n_plus_two_square, h_zeta, R_MOD)
        mstore(add(state, STATE_ZETA_POWER_N_PLUS_TWO), zeta_power_n_plus_two)
        mstore(add(state, STATE_ZETA_POWER_N_PLUS_TWO_SQUARE), zeta_power_n_plus_two_square)
      }

      /// @notice check that the opening of the linearised polynomial at zeta is equal to
      /// - [ PI(Œ∂) - Œ±¬≤*L‚ÇÅ(Œ∂) + Œ±(l(Œ∂)+Œ≤*s1(Œ∂)+Œ≥)(r(Œ∂)+Œ≤*s2(Œ∂)+Œ≥)(o(Œ∂)+Œ≥)*z(œâŒ∂) ]
      /// @param aproof pointer to the proof
      function compute_opening_linearised_polynomial(aproof) {
        
        let state := mload(0x40)

        // (l(Œ∂)+Œ≤*s1(Œ∂)+Œ≥)
        let s1
        s1 := mulmod(calldataload(add(aproof, PROOF_S1_AT_ZETA)), mload(add(state, STATE_BETA)), R_MOD)
        s1 := addmod(s1, mload(add(state, STATE_GAMMA)), R_MOD)
        s1 := addmod(s1, calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD)

        // (r(Œ∂)+Œ≤*s2(Œ∂)+Œ≥)
        let s2
        s2 := mulmod(calldataload(add(aproof, PROOF_S2_AT_ZETA)), mload(add(state, STATE_BETA)), R_MOD)
        s2 := addmod(s2, mload(add(state, STATE_GAMMA)), R_MOD)
        s2 := addmod(s2, calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)

        // (o(Œ∂)+Œ≥)
        let o
        o := addmod(calldataload(add(aproof, PROOF_O_AT_ZETA)), mload(add(state, STATE_GAMMA)), R_MOD)

        //  Œ±*Z(ŒºŒ∂)*(l(Œ∂)+Œ≤*s1(Œ∂)+Œ≥)*(r(Œ∂)+Œ≤*s2(Œ∂)+Œ≥)*(o(Œ∂)+Œ≥)
        s1 := mulmod(s1, s2, R_MOD)
        s1 := mulmod(s1, o, R_MOD)
        s1 := mulmod(s1, mload(add(state, STATE_ALPHA)), R_MOD)
        s1 := mulmod(s1, calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)), R_MOD)

        // PI(Œ∂) - Œ±¬≤*L‚ÇÅ(Œ∂) + Œ±(l(Œ∂)+Œ≤*s1(Œ∂)+Œ≥)(r(Œ∂)+Œ≤*s2(Œ∂)+Œ≥)(o(Œ∂)+Œ≥)*z(œâŒ∂)
        s1 := addmod(s1, mload(add(state, STATE_PI)), R_MOD)
        s2 := mload(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0))
        s2 := sub(R_MOD, s2)
        s1 := addmod(s1, s2, R_MOD)
        s1 := sub(R_MOD, s1)

        mstore(add(state, STATE_OPENING_LINEARISED_POLYNOMIAL_ZETA), s1)
      }

      // BEGINNING utils math functions -------------------------------------------------

      /// @notice dst <- dst + src*s (Fr) dst,src are addresses, s is a value
      /// @param dst pointer storing the result
      /// @param src pointer to the scalar to multiply and add (on calldata)
      /// @param s scalar
      function fr_acc_mul_calldata(dst, src, s) {
        let tmp :=  mulmod(calldataload(src), s, R_MOD)
        mstore(dst, addmod(mload(dst), tmp, R_MOD))
      }

      /// @param x element to exponentiate
      /// @param e exponent
      /// @param mPtr free memory
      /// @return res x ** e mod r
      function pow(x, e, mPtr)->res {
        mstore(mPtr, 0x20)
        mstore(add(mPtr, 0x20), 0x20)
        mstore(add(mPtr, 0x40), 0x20)
        mstore(add(mPtr, 0x60), x)
        mstore(add(mPtr, 0x80), e)
        mstore(add(mPtr, 0xa0), R_MOD)
        let check_staticcall := staticcall(gas(),MOD_EXP,mPtr,0xc0,mPtr,0x20)
        if eq(check_staticcall, 0) {
            error_mod_exp()
        }
        res := mload(mPtr)
      }
    }
		return success;
	}
}
