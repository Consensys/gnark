// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

pragma solidity ^0.8.0;

import { A } from "a.sol";
import { B } from "b.sol";

contract PlonkVerifier is IVerifier {

  uint256 private constant R_MOD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
  uint256 private constant R_MOD_MINUS_ONE = 21888242871839275222246405745257275088548364400416034343698204186575808495616;
  uint256 private constant P_MOD = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
  
  uint256 private constant G2_SRS_0_X_0 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
  uint256 private constant G2_SRS_0_X_1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
  uint256 private constant G2_SRS_0_Y_0 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
  uint256 private constant G2_SRS_0_Y_1 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
  
  uint256 private constant G2_SRS_1_X_0 = 3387804039520791566984593153059895751802824620550153002770775447157161732589;
  uint256 private constant G2_SRS_1_X_1 = 9166188542539813202185149037505057849575325698164322012564700036547816960027;
  uint256 private constant G2_SRS_1_Y_0 = 2634638714664788312731982309005124870087273547201621902090649916424524570523;
  uint256 private constant G2_SRS_1_Y_1 = 4405344944710413737397085719661434789785836524209896977248417499473480624852;
  
  uint256 private constant G1_SRS_X = 1;
  uint256 private constant G1_SRS_Y = 2;

  // ----------------------- vk ---------------------
  uint256 private constant VK_NB_PUBLIC_INPUTS = 3;
  uint256 private constant VK_DOMAIN_SIZE = 8;
  uint256 private constant VK_INV_DOMAIN_SIZE = 19152212512859365819465605027100115702479818850364030050735928663253832433665;
  uint256 private constant VK_OMEGA = 19540430494807482326159819597004422086093766032135589407132600596362845576832;
  uint256 private constant VK_QL_COM_X = 11057328297923587540854886103003876312549813916120723198623626247003990975580;
  uint256 private constant VK_QL_COM_Y = 2637706740780745053930169724397360068724296381906805677545883253878600403843;
  uint256 private constant VK_QR_COM_X = 18093675830305006689622839858921812180415077293030977105849120950910316817334;
  uint256 private constant VK_QR_COM_Y = 17636963782953941546443887494090613916563766721095825550304361506613191866339;
  uint256 private constant VK_QM_COM_X = 7718251824463489186091909809633092128710469076394118315830070803038286671495;
  uint256 private constant VK_QM_COM_Y = 9386701592770881396269455116253494709297497712173270692897406117772243318895;
  uint256 private constant VK_QO_COM_X = 7718251824463489186091909809633092128710469076394118315830070803038286671495;
  uint256 private constant VK_QO_COM_Y = 12501541279068393825976950629003780379398813445124552969791631776872982889688;
  uint256 private constant VK_QK_COM_X = 0;
  uint256 private constant VK_QK_COM_Y = 0;
  
  uint256 private constant VK_S1_COM_X = 4713031146473455288422495133787035360618133226805363858313249524614348031011;
  uint256 private constant VK_S1_COM_Y = 20854894808431613467895175527359631440114019599694277745030912306349509714023;
  
  uint256 private constant VK_S2_COM_X = 19440001805867020620564001929080183566604029903608187900166495549360387753918;
  uint256 private constant VK_S2_COM_Y = 3277792210460828000455761173876339006099291058930690429105353317055066899275;
  
  uint256 private constant VK_S3_COM_X = 19502665723500963716284892340689013486382509197234490238994567642500138782384;
  uint256 private constant VK_S3_COM_Y = 3917914177060431595985434216262886538989365142648778992528141379800087638684;
  
  uint256 private constant VK_COSET_SHIFT = 5;
  
  
  
  uint256 private constant VK_NB_CUSTOM_GATES = 0;

  // ------------------------------------------------

  // size of the proof without call custom gate
  uint256 private constant FIXED_PROOF_SIZE = 0x300;

  // offset proof
  
  uint256 private constant PROOF_L_COM_X = 0x0;
  uint256 private constant PROOF_L_COM_Y = 0x20;
  uint256 private constant PROOF_R_COM_X = 0x40;
  uint256 private constant PROOF_R_COM_Y = 0x60;
  uint256 private constant PROOF_O_COM_X = 0x80;
  uint256 private constant PROOF_O_COM_Y = 0xa0;

  // h = h_0 + x^{n+2}h_1 + x^{2(n+2)}h_2
  uint256 private constant PROOF_H_0_COM_X = 0xc0;
  uint256 private constant PROOF_H_0_COM_Y = 0xe0;
  uint256 private constant PROOF_H_1_COM_X = 0x100;
  uint256 private constant PROOF_H_1_COM_Y = 0x120;
  uint256 private constant PROOF_H_2_COM_X = 0x140;
  uint256 private constant PROOF_H_2_COM_Y = 0x160;

  // "evaluations of wire polynomials at zeta
  uint256 private constant PROOF_L_AT_ZETA = 0x180;
  uint256 private constant PROOF_R_AT_ZETA = 0x1a0;
  uint256 private constant PROOF_O_AT_ZETA = 0x1c0;

  // S1(zeta),S2(zeta)
  uint256 private constant PROOF_S1_AT_ZETA = 0x1e0; // SœÉ1(zeta)
  uint256 private constant PROOF_S2_AT_ZETA = 0x200; // SœÉ2(zeta)

  // [Z]
  uint256 private constant PROOF_GRAND_PRODUCT_COMMITMENT_X = 0x220;
  uint256 private constant PROOF_GRAND_PRODUCT_COMMITMENT_Y = 0x240;

  uint256 private constant PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA = 0x260; // z(w*zeta)

  // Folded proof for the opening of linearised poly, l, r, o, s_1, s_2, qcp
  uint256 private constant PROOF_BATCH_OPENING_AT_ZETA_X = 0x280;
  uint256 private constant PROOF_BATCH_OPENING_AT_ZETA_Y = 0x2a0;

  uint256 private constant PROOF_OPENING_AT_ZETA_OMEGA_X = 0x2c0;
  uint256 private constant PROOF_OPENING_AT_ZETA_OMEGA_Y = 0x2e0;

  uint256 private constant PROOF_OPENING_QCP_AT_ZETA = 0x300;
  uint256 private constant PROOF_BSB_COMMITMENTS = 0x300;

  // -------- offset state

  // challenges to check the claimed quotient
  
  uint256 private constant STATE_ALPHA = 0x0;
  uint256 private constant STATE_BETA = 0x20;
  uint256 private constant STATE_GAMMA = 0x40;
  uint256 private constant STATE_ZETA = 0x60;
  uint256 private constant STATE_ALPHA_SQUARE_LAGRANGE_0 = 0x80;
  uint256 private constant STATE_FOLDED_H_X = 0xa0;
  uint256 private constant STATE_FOLDED_H_Y = 0xc0;
  uint256 private constant STATE_LINEARISED_POLYNOMIAL_X = 0xe0;
  uint256 private constant STATE_LINEARISED_POLYNOMIAL_Y = 0x100;
  uint256 private constant STATE_OPENING_LINEARISED_POLYNOMIAL_ZETA = 0x120;
  uint256 private constant STATE_FOLDED_CLAIMED_VALUES = 0x140; // Folded proof for the opening of H, linearised poly, l, r, o, s_1, s_2, qcp
  uint256 private constant STATE_FOLDED_DIGESTS_X = 0x160; // linearised poly, l, r, o, s_1, s_2, qcp
  uint256 private constant STATE_FOLDED_DIGESTS_Y = 0x180;
  uint256 private constant STATE_PI = 0x1a0;
  uint256 private constant STATE_ZETA_POWER_N_MINUS_ONE = 0x1c0;
  uint256 private constant STATE_GAMMA_KZG = 0x1e0;
  uint256 private constant STATE_SUCCESS = 0x200;
  uint256 private constant STATE_CHECK_VAR = 0x220; // /!\ this slot is used for debugging only
  uint256 private constant STATE_LAST_MEM = 0x240;

  // -------- utils (for Fiat Shamir)
  uint256 private constant FS_ALPHA = 0x616C706861; // "alpha"
  uint256 private constant FS_BETA = 0x62657461; // "beta"
  uint256 private constant FS_GAMMA = 0x67616d6d61; // "gamma"
  uint256 private constant FS_ZETA = 0x7a657461; // "zeta"
  uint256 private constant FS_GAMMA_KZG = 0x67616d6d61; // "gamma"

  // -------- errors
  uint256 private constant ERROR_STRING_ID = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)

  

  // -------- precompiles
  uint8 private constant SHA2 = 0x2;
  uint8 private constant MOD_EXP = 0x5;
  uint8 private constant EC_ADD = 0x6;
  uint8 private constant EC_MUL = 0x7;
  uint8 private constant EC_PAIR = 0x8;

	bytes32 private immutable CHAIN_CONFIG;

	constructor(bytes32 config) {
		CHAIN_CONFIG = config;
  }
  
  /// Verify a Plonk proof.
  /// Reverts if the proof or the public inputs are malformed.
  /// @param proof serialised plonk proof (using gnark's MarshalSolidity)
  /// @param public_inputs (must be reduced)
  /// @return success true if the proof passes false otherwise
  function Verify(bytes calldata proof, uint256[] calldata public_inputs) 
  public view returns(bool success) {

    assembly {

      let mem := mload(0x40)
      let freeMem := add(mem, STATE_LAST_MEM)

      // sanity checks
      check_number_of_public_inputs(public_inputs.length)
      check_inputs_size(public_inputs.length, public_inputs.offset)
      check_proof_size(proof.length)
      check_proof_openings_size(proof.offset)

      // compute the challenges
      let prev_challenge_non_reduced
      prev_challenge_non_reduced := derive_gamma(proof.offset, public_inputs.length, public_inputs.offset)
      prev_challenge_non_reduced := derive_beta(prev_challenge_non_reduced)
      prev_challenge_non_reduced := derive_alpha(proof.offset, prev_challenge_non_reduced)
      derive_zeta(proof.offset, prev_challenge_non_reduced)

      // evaluation of Z=X‚Åø-1 at Œ∂, we save this value
      let zeta := mload(add(mem, STATE_ZETA))
      let zeta_power_n_minus_one := addmod(pow(zeta, VK_DOMAIN_SIZE, freeMem), sub(R_MOD, 1), R_MOD)
      mstore(add(mem, STATE_ZETA_POWER_N_MINUS_ONE), zeta_power_n_minus_one)

      // public inputs contribution
      let l_pi := sum_pi_wo_api_commit(public_inputs.offset, public_inputs.length, freeMem)
      mstore(add(mem, STATE_PI), l_pi)

      compute_alpha_square_lagrange_0()
      compute_opening_linearised_polynomial(proof.offset)
      fold_h(proof.offset)
      compute_commitment_linearised_polynomial(proof.offset)
      compute_gamma_kzg(proof.offset)
      fold_state(proof.offset)
      batch_verify_multi_points(proof.offset)

      success := mload(add(mem, STATE_SUCCESS))

      // Beginning errors -------------------------------------------------

      function error_nb_public_inputs() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x1d)
        mstore(add(ptError, 0x44), "wrong number of public inputs")
        revert(ptError, 0x64)
      }

      /// Called when an exponentiation mod r fails
      function error_mod_exp() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0xc)
        mstore(add(ptError, 0x44), "error mod exp")
        revert(ptError, 0x64)
      }

      /// Called when an operation on Bn254 fails
      /// @dev for instance when calling EcMul on a point not on Bn254.
      function error_ec_op() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x12)
        mstore(add(ptError, 0x44), "error ec operation")
        revert(ptError, 0x64)
      }

      /// Called when one of the public inputs is not reduced.
      function error_inputs_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x18)
        mstore(add(ptError, 0x44), "inputs are bigger than r")
        revert(ptError, 0x64)
      }

      /// Called when the size proof is not as expected
      /// @dev to avoid overflow attack for instance
      function error_proof_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x10)
        mstore(add(ptError, 0x44), "wrong proof size")
        revert(ptError, 0x64)
      }

      /// Called when one the openings is bigger than r
      /// The openings are the claimed evalutions of a polynomial
      /// in a Kzg proof.
      function error_proof_openings_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x16)
        mstore(add(ptError, 0x44), "openings bigger than r")
        revert(ptError, 0x64)
      }

      function error_pairing() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0xd)
        mstore(add(ptError, 0x44), "error pairing")
        revert(ptError, 0x64)
      }

      function error_verify() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0xc)
        mstore(add(ptError, 0x44), "error verify")
        revert(ptError, 0x64)
      }

      function error_random_generation() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x14)
        mstore(add(ptError, 0x44), "error random gen kzg")
        revert(ptError, 0x64)
      }
      // end errors -------------------------------------------------

      // Beginning checks -------------------------------------------------
      
      /// @param s actual number of public inputs
      function check_number_of_public_inputs(s) {
        if iszero(eq(s, VK_NB_PUBLIC_INPUTS)) {
          error_nb_public_inputs()
        }
      }
    
      /// Checks that the public inputs are < R_MOD.
      /// @param s number of public inputs
      /// @param p pointer to the public inputs array
      function check_inputs_size(s, p) {
        for {let i} lt(i, s) {i:=add(i,1)}
        {
          if gt(calldataload(p), R_MOD_MINUS_ONE) {
            error_inputs_size()
          }
          p := add(p, 0x20)
        }
      }

      /// Checks if the proof is of the correct size
      /// @param actual_proof_size size of the proof (not the expected size)
      function check_proof_size(actual_proof_size) {
        let expected_proof_size := add(FIXED_PROOF_SIZE, mul(VK_NB_CUSTOM_GATES,0x60))
        if iszero(eq(actual_proof_size, expected_proof_size)) {
         error_proof_size() 
        }
      }
    
      /// Checks if the multiple openings of the polynomials are < R_MOD.
      /// @param aproof pointer to the beginning of the proof
      /// @dev the 'a' prepending proof is to have a local name
      function check_proof_openings_size(aproof) {
        
        // PROOF_L_AT_ZETA
        let p := add(aproof, PROOF_L_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_R_AT_ZETA
        p := add(aproof, PROOF_R_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_O_AT_ZETA
        p := add(aproof, PROOF_O_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_S1_AT_ZETA
        p := add(aproof, PROOF_S1_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }
        
        // PROOF_S2_AT_ZETA
        p := add(aproof, PROOF_S2_AT_ZETA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA
        p := add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)
        if gt(calldataload(p), R_MOD_MINUS_ONE) {
          error_proof_openings_size()
        }

        // PROOF_OPENING_QCP_AT_ZETA
        
        p := add(aproof, PROOF_OPENING_QCP_AT_ZETA)
        for {let i:=0} lt(i, VK_NB_CUSTOM_GATES) {i:=add(i,1)}
        {
          if gt(calldataload(p), R_MOD_MINUS_ONE) {
            error_proof_openings_size()
          }
          p := add(p, 0x20)
        }

      }
      // end checks -------------------------------------------------

      // Beginning challenges -------------------------------------------------

      /// Derive gamma as Sha256(<transcript>)
      /// @param aproof pointer to the proof
      /// @param nb_pi number of public inputs
      /// @param pi pointer to the array of public inputs
      /// @return the challenge gamma, not reduced
      /// @notice The transcript is the concatenation (in this order) of:
      /// * the word "gamma" in ascii, equal to [0x67,0x61,0x6d, 0x6d, 0x61] and encoded as a uint256.
      /// * the commitments to the permutation polynomials S1, S2, S3, where we concatenate the coordinates of those points
      /// * the commitments of Ql, Qr, Qm, Qo, Qk
      /// * the public inputs
      /// * the commitments of the wires related to the custom gates (commitments_wires_commit_api)
      /// * commitments to L, R, O (proof_<l,r,o>_com_<x,y>)
      /// The data described above is written starting at mPtr. "gamma" lies on 5 bytes,
      /// and is encoded as a uint256 number n. In basis b = 256, the number looks like this
      /// [0 0 0 .. 0x67 0x61 0x6d, 0x6d, 0x61]. The first non zero entry is at position 27=0x1b
      /// Gamma reduced (the actual challenge) is stored at add(state, state_gamma)
      function derive_gamma(aproof, nb_pi, pi)->gamma_not_reduced {
        
        let state := mload(0x40)
        let mPtr := add(state, STATE_LAST_MEM)

        mstore(mPtr, FS_GAMMA) // "gamma"

        
        mstore(add(mPtr, 0x20), VK_S1_COM_X) 
        mstore(add(mPtr, 0x40), VK_S1_COM_Y) 
        mstore(add(mPtr, 0x60), VK_S2_COM_X) 
        mstore(add(mPtr, 0x80), VK_S2_COM_Y) 
        mstore(add(mPtr, 0xa0), VK_S3_COM_X) 
        mstore(add(mPtr, 0xc0), VK_S3_COM_Y) 
        mstore(add(mPtr, 0xe0), VK_QL_COM_X) 
        mstore(add(mPtr, 0x100), VK_QL_COM_Y) 
        mstore(add(mPtr, 0x120), VK_QR_COM_X) 
        mstore(add(mPtr, 0x140), VK_QR_COM_Y) 
        mstore(add(mPtr, 0x160), VK_QM_COM_X) 
        mstore(add(mPtr, 0x180), VK_QM_COM_Y) 
        mstore(add(mPtr, 0x1a0), VK_QO_COM_X) 
        mstore(add(mPtr, 0x1c0), VK_QO_COM_Y) 
        mstore(add(mPtr, 0x1e0), VK_QK_COM_X) 
        mstore(add(mPtr, 0x200), VK_QK_COM_Y) 
        
        // public inputs
        let _mPtr := add(mPtr, 0x220)
        let size_pi_in_bytes := mul(nb_pi, 0x20)
        calldatacopy(_mPtr, pi, size_pi_in_bytes)
        _mPtr := add(_mPtr, size_pi_in_bytes)

        // commitments to l, r, o
        let size_commitments_lro_in_bytes := 0xc0
        calldatacopy(_mPtr, aproof, size_commitments_lro_in_bytes)
        _mPtr := add(_mPtr, size_commitments_lro_in_bytes)

        // total size is :
        // sizegamma(=0x5) + 11*64(=0x2c0)
        // + nb_public_inputs*0x20
        // + nb_custom gates*0x40
        let size := add(0x2c5, size_pi_in_bytes)
        let l_success := staticcall(gas(), SHA2, add(mPtr, 0x1b), size, mPtr, 0x20) //0x1b -> 000.."gamma"
        if iszero(l_success) {
          error_verify()
        }
        gamma_not_reduced := mload(mPtr)
        mstore(add(state, STATE_GAMMA), mod(gamma_not_reduced, R_MOD))
      }

      /// derive beta as Sha256<transcript>
      /// @param gamma_not_reduced the previous challenge (gamma) not reduced
      /// @return beta_not_reduced the next challenge, beta, not reduced
      /// @notice the transcript consists of the previous challenge only.
      /// The reduced version of beta is stored at add(state, state_beta)
      function derive_beta(gamma_not_reduced)->beta_not_reduced{
        
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        // beta
        mstore(mPtr, FS_BETA) // "beta"
        mstore(add(mPtr, 0x20), gamma_not_reduced)
        let l_success := staticcall(gas(), SHA2, add(mPtr, 0x1c), 0x24, mPtr, 0x20) //0x1b -> 000.."gamma"
        if iszero(l_success) {
          error_verify()
        }
        beta_not_reduced := mload(mPtr)
        mstore(add(state, STATE_BETA), mod(beta_not_reduced, R_MOD))
      }

      /// derive alpha as sha256<transcript>
      /// @param aproof pointer to the proof object
      /// @param beta_not_reduced the previous challenge (beta) not reduced
      /// @return alpha_not_reduced the next challenge, alpha, not reduced
      /// @notice the transcript consists of the previous challenge (beta)
      /// not reduced, the commitments to the wires associated to the QCP_i,
      /// and the commitment to the grand product polynomial 
      function derive_alpha(aproof, beta_not_reduced)->alpha_not_reduced {
        
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)
        let full_size := 0x65 // size("alpha") + 0x20 (previous challenge)

        // alpha
        mstore(mPtr, FS_ALPHA) // "alpha"
        let _mPtr := add(mPtr, 0x20)
        mstore(_mPtr, beta_not_reduced)
        _mPtr := add(_mPtr, 0x20)
        
        // [Z], the commitment to the grand product polynomial
        calldatacopy(_mPtr, add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X), 0x40)
        let l_success := staticcall(gas(), SHA2, add(mPtr, 0x1b), full_size, mPtr, 0x20)
        if iszero(l_success) {
          error_verify()
        }

        alpha_not_reduced := mload(mPtr)
        mstore(add(state, STATE_ALPHA), mod(alpha_not_reduced, R_MOD))
      }

      /// derive zeta as sha256<transcript>
      /// @param aproof pointer to the proof object
      /// @param alpha_not_reduced the previous challenge (alpha) not reduced
      /// The transcript consists of the previous challenge and the commitment to
      /// the quotient polynomial h.
      function derive_zeta(aproof, alpha_not_reduced) {
        
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        // zeta
        mstore(mPtr, FS_ZETA) // "zeta"
        mstore(add(mPtr, 0x20), alpha_not_reduced)
        calldatacopy(add(mPtr, 0x40), add(aproof, PROOF_H_0_COM_X), 0xc0)
        let l_success := staticcall(gas(), SHA2, add(mPtr, 0x1c), 0xe4, mPtr, 0x20)
        if iszero(l_success) {
          error_verify()
        }
        let zeta_not_reduced := mload(mPtr)
        mstore(add(state, STATE_ZETA), mod(zeta_not_reduced, R_MOD))
      }
      // END challenges -------------------------------------------------

      // BEGINNING compute_pi -------------------------------------------------

      /// sum_pi_wo_api_commit computes the public inputs contributions,
      /// except for the public inputs coming from the custom gate
      /// @param ins pointer to the public inputs
      /// @param n number of public inputs
      /// @param mPtr free memory
      /// @return pi_wo_commit public inputs contribution (except the public inputs coming from the custom gate)
      function sum_pi_wo_api_commit(ins, n, mPtr)->pi_wo_commit {
        
        let state := mload(0x40)
        let z := mload(add(state, STATE_ZETA))
        let zpnmo := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))

        let li := mPtr
        batch_compute_lagranges_at_z(z, zpnmo, n, li)

        let tmp := 0
        for {let i:=0} lt(i,n) {i:=add(i,1)}
        {
          tmp := mulmod(mload(li), calldataload(ins), R_MOD)
          pi_wo_commit := addmod(pi_wo_commit, tmp, R_MOD)
          li := add(li, 0x20)
          ins := add(ins, 0x20)
        }
        
      }

      /// batch_compute_lagranges_at_z computes [L_0(z), .., L_{n-1}(z)]
      /// @param z point at which the Lagranges are evaluated
      /// @param zpnmo Œ∂‚Åø-1
      /// @param n_pub number of public inputs (number of Lagranges to compute)
      /// @param mPtr pointer to which the results are stored
      function batch_compute_lagranges_at_z(z, zpnmo, n_pub, mPtr) {

        let zn := mulmod(zpnmo, VK_INV_DOMAIN_SIZE, R_MOD) // 1/n * (Œ∂‚Åø - 1)
        
        let _w := 1
        let _mPtr := mPtr
        for {let i:=0} lt(i,n_pub) {i:=add(i,1)}
        {
          mstore(_mPtr, addmod(z,sub(R_MOD, _w), R_MOD))
          _w := mulmod(_w, VK_OMEGA, R_MOD)
          _mPtr := add(_mPtr, 0x20)
        }
        batch_invert(mPtr, n_pub, _mPtr)
        _mPtr := mPtr
        _w := 1
        for {let i:=0} lt(i,n_pub) {i:=add(i,1)}
        {
          mstore(_mPtr, mulmod(mulmod(mload(_mPtr), zn , R_MOD), _w, R_MOD))
          _mPtr := add(_mPtr, 0x20)
          _w := mulmod(_w, VK_OMEGA, R_MOD)
        }
      } 

      /// @notice Montgomery trick for batch inversion mod R_MOD
      /// @param ins pointer to the data to batch invert
      /// @param number of elements to batch invert
      /// @param mPtr free memory
      function batch_invert(ins, nb_ins, mPtr) {
        mstore(mPtr, 1)
        let offset := 0
        for {let i:=0} lt(i, nb_ins) {i:=add(i,1)}
        {
          let prev := mload(add(mPtr, offset))
          let cur := mload(add(ins, offset))
          cur := mulmod(prev, cur, R_MOD)
          offset := add(offset, 0x20)
          mstore(add(mPtr, offset), cur)
        }
        ins := add(ins, sub(offset, 0x20))
        mPtr := add(mPtr, offset)
        let inv := pow(mload(mPtr), sub(R_MOD,2), add(mPtr, 0x20))
        for {let i:=0} lt(i, nb_ins) {i:=add(i,1)}
        {
          mPtr := sub(mPtr, 0x20)
          let tmp := mload(ins)
          let cur := mulmod(inv, mload(mPtr), R_MOD)
          mstore(ins, cur)
          inv := mulmod(inv, tmp, R_MOD)
          ins := sub(ins, 0x20)
        }
      }

      
      // END compute_pi -------------------------------------------------

      /// @notice compute Œ±¬≤ * 1/n * (Œ∂{n}-1)/(Œ∂ - 1) where
      /// *  Œ± = challenge derived in derive_gamma_beta_alpha_zeta
      /// * n = vk_domain_size
      /// * œâ = vk_omega (generator of the multiplicative cyclic group of order n in (‚Ñ§/r‚Ñ§)*)
      /// * Œ∂ = zeta (challenge derived with Fiat Shamir)
      function compute_alpha_square_lagrange_0() {   
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        let res := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))
        let den := addmod(mload(add(state, STATE_ZETA)), sub(R_MOD, 1), R_MOD)
        den := pow(den, sub(R_MOD, 2), mPtr)
        den := mulmod(den, VK_INV_DOMAIN_SIZE, R_MOD)
        res := mulmod(den, res, R_MOD)

        let l_alpha := mload(add(state, STATE_ALPHA))
        res := mulmod(res, l_alpha, R_MOD)
        res := mulmod(res, l_alpha, R_MOD)
        mstore(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0), res)
      }

      /// @notice follows alg. p.13 of https://eprint.iacr.org/2019/953.pdf
      /// with t‚ÇÅ = t‚ÇÇ = 1, and the proofs are ([digest] + [quotient] +purported evaluation):
      /// * [state_folded_state_digests], [proof_batch_opening_at_zeta_x], state_folded_evals
      /// * [proof_grand_product_commitment], [proof_opening_at_zeta_omega_x], [proof_grand_product_at_zeta_omega]
      /// @param aproof pointer to the proof
      function batch_verify_multi_points(aproof) {
        let state := mload(0x40)
        let mPtr := add(state, STATE_LAST_MEM)

        // derive a random number. As there is no random generator, we
        // do an FS like challenge derivation, depending on both digests and
        // Œ∂ to ensure that the prover cannot control the random number.
        // Note: adding the other point Œ∂œâ is not needed, as œâ is known beforehand.
        mstore(mPtr, mload(add(state, STATE_FOLDED_DIGESTS_X)))
        mstore(add(mPtr, 0x20), mload(add(state, STATE_FOLDED_DIGESTS_Y)))
        mstore(add(mPtr, 0x40), calldataload(add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X)))
        mstore(add(mPtr, 0x60), calldataload(add(aproof, PROOF_BATCH_OPENING_AT_ZETA_Y)))
        mstore(add(mPtr, 0x80), calldataload(add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X)))
        mstore(add(mPtr, 0xa0), calldataload(add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_Y)))
        mstore(add(mPtr, 0xc0), calldataload(add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X)))
        mstore(add(mPtr, 0xe0), calldataload(add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_Y)))
        mstore(add(mPtr, 0x100), mload(add(state, STATE_ZETA)))
        mstore(add(mPtr, 0x120), mload(add(state, STATE_GAMMA_KZG)))
        let random := staticcall(gas(), SHA2, mPtr, 0x140, mPtr, 0x20)
        if iszero(random){
          error_random_generation()
        }
        random := mod(mload(mPtr), R_MOD) // use the same variable as we are one variable away from getting stack-too-deep error...

        let folded_quotients := mPtr
        mPtr := add(folded_quotients, 0x40)
        mstore(folded_quotients, calldataload(add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X)))
        mstore(add(folded_quotients, 0x20), calldataload(add(aproof, PROOF_BATCH_OPENING_AT_ZETA_Y)))
        point_acc_mul_calldata(folded_quotients, add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X), random, mPtr)

        let folded_digests := add(state, STATE_FOLDED_DIGESTS_X)
        point_acc_mul_calldata(folded_digests, add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X), random, mPtr)

        let folded_evals := add(state, STATE_FOLDED_CLAIMED_VALUES)
        fr_acc_mul_calldata(folded_evals, add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA), random)

        let folded_evals_commit := mPtr
        mPtr := add(folded_evals_commit, 0x40)
        mstore(folded_evals_commit, G1_SRS_X)
        mstore(add(folded_evals_commit, 0x20), G1_SRS_Y)
        mstore(add(folded_evals_commit, 0x40), mload(folded_evals))
        let check_staticcall := staticcall(gas(), 7, folded_evals_commit, 0x60, folded_evals_commit, 0x40)
        if iszero(check_staticcall) {
          error_verify()
        }

        let folded_evals_commit_y := add(folded_evals_commit, 0x20)
        mstore(folded_evals_commit_y, sub(P_MOD, mload(folded_evals_commit_y)))
        point_add(folded_digests, folded_digests, folded_evals_commit, mPtr)

        let folded_points_quotients := mPtr
        mPtr := add(mPtr, 0x40)
        point_mul_calldata(
          folded_points_quotients,
          add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X),
          mload(add(state, STATE_ZETA)),
          mPtr
        )
        let zeta_omega := mulmod(mload(add(state, STATE_ZETA)), VK_OMEGA, R_MOD)
        random := mulmod(random, zeta_omega, R_MOD)
        point_acc_mul_calldata(folded_points_quotients, add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X), random, mPtr)

        point_add(folded_digests, folded_digests, folded_points_quotients, mPtr)

        let folded_quotients_y := add(folded_quotients, 0x20)
        mstore(folded_quotients_y, sub(P_MOD, mload(folded_quotients_y)))

        mstore(mPtr, mload(folded_digests))
        
        mstore(add(mPtr, 0x20), mload(add(folded_digests, 0x20))) 
        mstore(add(mPtr, 0x40), G2_SRS_0_X_0)  // the 4 lines are the canonical G2 point on BN254
        mstore(add(mPtr, 0x60), G2_SRS_0_X_1) 
        mstore(add(mPtr, 0x80), G2_SRS_0_Y_0) 
        mstore(add(mPtr, 0xa0), G2_SRS_0_Y_1) 
        mstore(add(mPtr, 0xc0), mload(folded_quotients)) 
        mstore(add(mPtr, 0xe0), mload(add(folded_quotients, 0x20))) 
        mstore(add(mPtr, 0x100), G2_SRS_1_X_0) 
        mstore(add(mPtr, 0x120), G2_SRS_1_X_1) 
        mstore(add(mPtr, 0x140), G2_SRS_1_Y_0) 
        mstore(add(mPtr, 0x160), G2_SRS_1_Y_1) 
        check_pairing_kzg(mPtr)
      }

      /// @notice check_pairing_kzg checks the result of the final pairing product of the batched
      /// kzg verification. The purpose of this function is to avoid exhausting the stack
      /// in the function batch_verify_multi_points.
      /// @param mPtr pointer storing the tuple of pairs
      function check_pairing_kzg(mPtr) {
        let state := mload(0x40)

        let l_success := staticcall(gas(), 8, mPtr, 0x180, 0x00, 0x20)
        if iszero(l_success) {
          error_pairing()
        }
        let res_pairing := mload(0x00)
        mstore(add(state, STATE_SUCCESS), res_pairing)
      }

      /// @notice Fold the opening proofs at Œ∂:
      /// * at state+state_folded_digest we store: [Linearised_polynomial]+Œ≥[L] + Œ≥¬≤[R] + Œ≥¬≥[O] + Œ≥‚Å¥[S‚ÇÅ] +Œ≥‚Åµ[S‚ÇÇ] + ‚àë·µ¢Œ≥‚Åµ‚Å∫‚Å±[Pi_{i}]
      /// * at state+state_folded_claimed_values we store: Linearised_polynomial(Œ∂)+Œ≥L(Œ∂) + Œ≥¬≤R(Œ∂)+ Œ≥¬≥O(Œ∂) + Œ≥‚Å¥S‚ÇÅ(Œ∂) +Œ≥‚ÅµS‚ÇÇ(Œ∂) + ‚àë·µ¢Œ≥‚Åµ‚Å∫‚Å±Pi_{i}(Œ∂)
      /// @param aproof pointer to the proof
      /// acc_gamma stores the Œ≥‚Å±
      function fold_state(aproof) {

        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)
        let mPtr20 := add(mPtr, 0x20)
        let mPtr40 := add(mPtr, 0x40)

        let l_gamma_kzg := mload(add(state, STATE_GAMMA_KZG))
        let acc_gamma := l_gamma_kzg
        let state_folded_digests := add(state, STATE_FOLDED_DIGESTS_X)

        mstore(state_folded_digests, mload(add(state, STATE_LINEARISED_POLYNOMIAL_X)))
        mstore(add(state, STATE_FOLDED_DIGESTS_Y), mload(add(state, STATE_LINEARISED_POLYNOMIAL_Y)))
        mstore(add(state, STATE_FOLDED_CLAIMED_VALUES), mload(add(state, STATE_OPENING_LINEARISED_POLYNOMIAL_ZETA)))

        point_acc_mul_calldata(state_folded_digests, add(aproof, PROOF_L_COM_X), acc_gamma, mPtr)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_L_AT_ZETA), acc_gamma)

        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        point_acc_mul_calldata(state_folded_digests, add(aproof, PROOF_R_COM_X), acc_gamma, mPtr)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_R_AT_ZETA), acc_gamma)

        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        point_acc_mul_calldata(state_folded_digests, add(aproof, PROOF_O_COM_X), acc_gamma, mPtr)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_O_AT_ZETA), acc_gamma)

        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        mstore(mPtr, VK_S1_COM_X)
        mstore(mPtr20, VK_S1_COM_Y)
        point_acc_mul(state_folded_digests, mPtr, acc_gamma, mPtr40)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_S1_AT_ZETA), acc_gamma)

        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)
        mstore(mPtr, VK_S2_COM_X)
        mstore(mPtr20, VK_S2_COM_Y)
        point_acc_mul(state_folded_digests, mPtr, acc_gamma, mPtr40)
        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_S2_AT_ZETA), acc_gamma)}

      /// @notice generate the challenge (using Fiat Shamir) to fold the opening proofs
      /// at Œ∂.
      /// The process for deriving Œ≥ is the same as in derive_gamma but this time the inputs are
      /// in this order (the [] means it's a commitment):
      /// * Œ∂
      /// * [Linearised polynomial]
      /// * [L], [R], [O]
      /// * [S‚ÇÅ] [S‚ÇÇ]
      /// * [Pi_{i}] (wires associated to custom gates)
      /// Then there are the purported evaluations of the previous committed polynomials:
      /// * Linearised_polynomial(Œ∂)
      /// * L(Œ∂), R(Œ∂), O(Œ∂), S‚ÇÅ(Œ∂), S‚ÇÇ(Œ∂)
      /// * Pi_{i}(Œ∂)
      /// * Z(Œ∂œâ)
      /// @param aproof pointer to the proof
      function compute_gamma_kzg(aproof) {

        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)
        mstore(mPtr, FS_GAMMA_KZG) // "gamma"
        mstore(add(mPtr, 0x20), mload(add(state, STATE_ZETA)))
        mstore(add(mPtr,0x40), mload(add(state, STATE_LINEARISED_POLYNOMIAL_X)))
        mstore(add(mPtr,0x60), mload(add(state, STATE_LINEARISED_POLYNOMIAL_Y)))
        calldatacopy(add(mPtr, 0x80), add(aproof, PROOF_L_COM_X), 0xc0)
        mstore(add(mPtr,0x140), VK_S1_COM_X)
        mstore(add(mPtr,0x160), VK_S1_COM_Y)
        mstore(add(mPtr,0x180), VK_S2_COM_X)
        mstore(add(mPtr,0x1a0), VK_S2_COM_Y)
        
        let offset := 0x1c0
        
        mstore(add(mPtr, offset), mload(add(state, STATE_OPENING_LINEARISED_POLYNOMIAL_ZETA)))
        mstore(add(mPtr, add(offset, 0x20)), calldataload(add(aproof, PROOF_L_AT_ZETA)))
        mstore(add(mPtr, add(offset, 0x40)), calldataload(add(aproof, PROOF_R_AT_ZETA)))
        mstore(add(mPtr, add(offset, 0x60)), calldataload(add(aproof, PROOF_O_AT_ZETA)))
        mstore(add(mPtr, add(offset, 0x80)), calldataload(add(aproof, PROOF_S1_AT_ZETA)))
        mstore(add(mPtr, add(offset, 0xa0)), calldataload(add(aproof, PROOF_S2_AT_ZETA)))

        let _mPtr := add(mPtr, add(offset, 0xc0))

        

        mstore(_mPtr, calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)))

        let start_input := 0x1b // 00.."gamma"
        let size_input := add(0x14, mul(VK_NB_CUSTOM_GATES,3)) // number of 32bytes elmts = 0x14 (zeta+3*6 for the digests+openings) + 3*VK_NB_CUSTOM_GATES (for the commitments of the selectors) + 1 (opening of Z at Œ∂œâ)
        size_input := add(0x5, mul(size_input, 0x20)) // size in bytes: 15*32 bytes + 5 bytes for gamma
        let check_staticcall := staticcall(gas(), SHA2, add(mPtr,start_input), size_input, add(state, STATE_GAMMA_KZG), 0x20)
        if iszero(check_staticcall) {
          error_verify()
        }
        mstore(add(state, STATE_GAMMA_KZG), mod(mload(add(state, STATE_GAMMA_KZG)), R_MOD))
      }

      function compute_commitment_linearised_polynomial_ec(aproof, s1, s2) {
        
        let state := mload(0x40)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)

        mstore(mPtr, VK_QL_COM_X)
        mstore(add(mPtr, 0x20), VK_QL_COM_Y)
        point_mul(
          add(state, STATE_LINEARISED_POLYNOMIAL_X),
          mPtr,
          calldataload(add(aproof, PROOF_L_AT_ZETA)),
          add(mPtr, 0x40)
        )

        mstore(mPtr, VK_QR_COM_X)
        mstore(add(mPtr, 0x20), VK_QR_COM_Y)
        point_acc_mul(
          add(state, STATE_LINEARISED_POLYNOMIAL_X),
          mPtr,
          calldataload(add(aproof, PROOF_R_AT_ZETA)),
          add(mPtr, 0x40)
        )

        let rl := mulmod(calldataload(add(aproof, PROOF_L_AT_ZETA)), calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)
        mstore(mPtr, VK_QM_COM_X)
        mstore(add(mPtr, 0x20), VK_QM_COM_Y)
        point_acc_mul(add(state, STATE_LINEARISED_POLYNOMIAL_X), mPtr, rl, add(mPtr, 0x40))

        mstore(mPtr, VK_QO_COM_X)
        mstore(add(mPtr, 0x20), VK_QO_COM_Y)
        point_acc_mul(
          add(state, STATE_LINEARISED_POLYNOMIAL_X),
          mPtr,
          calldataload(add(aproof, PROOF_O_AT_ZETA)),
          add(mPtr, 0x40)
        )

        mstore(mPtr, VK_QK_COM_X)
        mstore(add(mPtr, 0x20), VK_QK_COM_Y)
        point_add(
          add(state, STATE_LINEARISED_POLYNOMIAL_X),
          add(state, STATE_LINEARISED_POLYNOMIAL_X),
          mPtr,
          add(mPtr, 0x40)
        )

        

        mstore(mPtr, VK_S3_COM_X)
        mstore(add(mPtr, 0x20), VK_S3_COM_Y)
        point_acc_mul(add(state, STATE_LINEARISED_POLYNOMIAL_X), mPtr, s1, add(mPtr, 0x40))

        mstore(mPtr, calldataload(add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X)))
        mstore(add(mPtr, 0x20), calldataload(add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_Y)))
        point_acc_mul(add(state, STATE_LINEARISED_POLYNOMIAL_X), mPtr, s2, add(mPtr, 0x40))

        point_add(
          add(state, STATE_LINEARISED_POLYNOMIAL_X), 
          add(state, STATE_LINEARISED_POLYNOMIAL_X), 
          add(state, STATE_FOLDED_H_X), 
          mPtr)
      }

      /// @notice Compute the commitment to the linearized polynomial equal to
      ///	L(Œ∂)[Q‚Çó]+r(Œ∂)[Q·µ£]+R(Œ∂)L(Œ∂)[Q‚Çò]+O(Œ∂)[Q‚Çí]+[Q‚Çñ]+Œ£·µ¢qc'·µ¢(Œ∂)[BsbCommitment·µ¢] +
      ///	Œ±*( Z(ŒºŒ∂)(L(Œ∂)+Œ≤*S‚ÇÅ(Œ∂)+Œ≥)*(R(Œ∂)+Œ≤*S‚ÇÇ(Œ∂)+Œ≥)[S‚ÇÉ]-[Z](L(Œ∂)+Œ≤*id_{1}(Œ∂)+Œ≥)*(R(Œ∂)+Œ≤*id_{2}(Œ∂)+Œ≥)*(O(Œ∂)+Œ≤*id_{3}(Œ∂)+Œ≥) ) +
      ///	Œ±¬≤*L‚ÇÅ(Œ∂)[Z] - Z_{H}(Œ∂)*(([H‚ÇÄ] + Œ∂·µê‚Å∫¬≤*[H‚ÇÅ] + Œ∂¬≤‚ÅΩ·µê‚Å∫¬≤‚Åæ*[H‚ÇÇ])
      /// where
      /// * id_1 = id, id_2 = vk_coset_shift*id, id_3 = vk_coset_shift^{2}*id
      /// * the [] means that it's a commitment (i.e. a point on Bn254(F_p))
      /// * Z_{H}(Œ∂) = Œ∂^n-1
      /// @param aproof pointer to the proof
      function compute_commitment_linearised_polynomial(aproof) {
        let state := mload(0x40)
        let l_beta := mload(add(state, STATE_BETA))
        let l_gamma := mload(add(state, STATE_GAMMA))
        let l_zeta := mload(add(state, STATE_ZETA))
        let l_alpha := mload(add(state, STATE_ALPHA))

        let u := mulmod(calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)), l_beta, R_MOD)
        let v := mulmod(l_beta, calldataload(add(aproof, PROOF_S1_AT_ZETA)), R_MOD)
        v := addmod(v, calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD)
        v := addmod(v, l_gamma, R_MOD)

        let w := mulmod(l_beta, calldataload(add(aproof, PROOF_S2_AT_ZETA)), R_MOD)
        w := addmod(w, calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)
        w := addmod(w, l_gamma, R_MOD)

        let s1 := mulmod(u, v, R_MOD)
        s1 := mulmod(s1, w, R_MOD)
        s1 := mulmod(s1, l_alpha, R_MOD)

        let coset_square := mulmod(VK_COSET_SHIFT, VK_COSET_SHIFT, R_MOD)
        let betazeta := mulmod(l_beta, l_zeta, R_MOD)
        u := addmod(betazeta, calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD)
        u := addmod(u, l_gamma, R_MOD)

        v := mulmod(betazeta, VK_COSET_SHIFT, R_MOD)
        v := addmod(v, calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)
        v := addmod(v, l_gamma, R_MOD)

        w := mulmod(betazeta, coset_square, R_MOD)
        w := addmod(w, calldataload(add(aproof, PROOF_O_AT_ZETA)), R_MOD)
        w := addmod(w, l_gamma, R_MOD)

        let s2 := mulmod(u, v, R_MOD)
        s2 := mulmod(s2, w, R_MOD)
        s2 := sub(R_MOD, s2)
        s2 := mulmod(s2, l_alpha, R_MOD)
        s2 := addmod(s2, mload(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0)), R_MOD)

        // at this stage:
        // * s‚ÇÅ = Œ±*Z(ŒºŒ∂)(l(Œ∂)+Œ≤*s‚ÇÅ(Œ∂)+Œ≥)*(r(Œ∂)+Œ≤*s‚ÇÇ(Œ∂)+Œ≥)*Œ≤
        // * s‚ÇÇ = -Œ±*(l(Œ∂)+Œ≤*Œ∂+Œ≥)*(r(Œ∂)+Œ≤*u*Œ∂+Œ≥)*(o(Œ∂)+Œ≤*u¬≤*Œ∂+Œ≥) + Œ±¬≤*L‚ÇÅ(Œ∂)

        compute_commitment_linearised_polynomial_ec(aproof, s1, s2)
      }

      /// @notice compute -z_h(Œ∂)*([H‚ÇÅ] + Œ∂‚Åø‚Å∫¬≤[H‚ÇÇ] + Œ∂¬≤‚ÅΩ‚Åø‚Å∫¬≤‚Åæ[H‚ÇÉ]) and store the result at
      /// state + state_folded_h
      /// @param aproof pointer to the proof
      function fold_h(aproof) {
        let state := mload(0x40)
        let n_plus_two := add(VK_DOMAIN_SIZE, 2)
        let mPtr := add(mload(0x40), STATE_LAST_MEM)
        let zeta_power_n_plus_two := pow(mload(add(state, STATE_ZETA)), n_plus_two, mPtr)
        point_mul_calldata(add(state, STATE_FOLDED_H_X), add(aproof, PROOF_H_2_COM_X), zeta_power_n_plus_two, mPtr)
        point_add_calldata(add(state, STATE_FOLDED_H_X), add(state, STATE_FOLDED_H_X), add(aproof, PROOF_H_1_COM_X), mPtr)
        point_mul(add(state, STATE_FOLDED_H_X), add(state, STATE_FOLDED_H_X), zeta_power_n_plus_two, mPtr)
        point_add_calldata(add(state, STATE_FOLDED_H_X), add(state, STATE_FOLDED_H_X), add(aproof, PROOF_H_0_COM_X), mPtr)
          point_mul(add(state, STATE_FOLDED_H_X), add(state, STATE_FOLDED_H_X), mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE)), mPtr)
        let folded_h_y := mload(add(state, STATE_FOLDED_H_Y))
        folded_h_y := sub(P_MOD, folded_h_y)
        mstore(add(state, STATE_FOLDED_H_Y), folded_h_y)
      }

      /// @notice check that the opening of the linearised polynomial at zeta is equal to
      /// - [ PI(Œ∂) - Œ±¬≤*L‚ÇÅ(Œ∂) + Œ±(l(Œ∂)+Œ≤*s1(Œ∂)+Œ≥)(r(Œ∂)+Œ≤*s2(Œ∂)+Œ≥)(o(Œ∂)+Œ≥)*z(œâŒ∂) ]
      /// @param aproof pointer to the proof
      function compute_opening_linearised_polynomial(aproof) {
        
        let state := mload(0x40)

        // (l(Œ∂)+Œ≤*s1(Œ∂)+Œ≥)
        let s1
        s1 := mulmod(calldataload(add(aproof, PROOF_S1_AT_ZETA)), mload(add(state, STATE_BETA)), R_MOD)
        s1 := addmod(s1, mload(add(state, STATE_GAMMA)), R_MOD)
        s1 := addmod(s1, calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD)

        // (r(Œ∂)+Œ≤*s2(Œ∂)+Œ≥)
        let s2
        s2 := mulmod(calldataload(add(aproof, PROOF_S2_AT_ZETA)), mload(add(state, STATE_BETA)), R_MOD)
        s2 := addmod(s2, mload(add(state, STATE_GAMMA)), R_MOD)
        s2 := addmod(s2, calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)

        // (o(Œ∂)+Œ≥)
        let o
        o := addmod(calldataload(add(aproof, PROOF_O_AT_ZETA)), mload(add(state, STATE_GAMMA)), R_MOD)

        //  Œ±*Z(ŒºŒ∂)*(l(Œ∂)+Œ≤*s1(Œ∂)+Œ≥)*(r(Œ∂)+Œ≤*s2(Œ∂)+Œ≥)*(o(Œ∂)+Œ≥)
        s1 := mulmod(s1, s2, R_MOD)
        s1 := mulmod(s1, o, R_MOD)
        s1 := mulmod(s1, mload(add(state, STATE_ALPHA)), R_MOD)
        s1 := mulmod(s1, calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)), R_MOD)

        // PI(Œ∂) - Œ±¬≤*L‚ÇÅ(Œ∂) + Œ±(l(Œ∂)+Œ≤*s1(Œ∂)+Œ≥)(r(Œ∂)+Œ≤*s2(Œ∂)+Œ≥)(o(Œ∂)+Œ≥)*z(œâŒ∂)
        s1 := addmod(s1, mload(add(state, STATE_PI)), R_MOD)
        s2 := mload(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0))
        s2 := sub(R_MOD, s2)
        s1 := addmod(s1, s2, R_MOD)
        s1 := sub(R_MOD, s1)

        mstore(add(state, STATE_OPENING_LINEARISED_POLYNOMIAL_ZETA), s1)
      }

      // BEGINNING utils math functions -------------------------------------------------
      
      /// @param dst pointer storing the result
      /// @param p pointer to the first point
      /// @param q pointer to the second point
      /// @param mPtr pointer to free memory
      function point_add(dst, p, q, mPtr) {
        mstore(mPtr, mload(p))
        mstore(add(mPtr, 0x20), mload(add(p, 0x20)))
        mstore(add(mPtr, 0x40), mload(q))
        mstore(add(mPtr, 0x60), mload(add(q, 0x20)))
        let l_success := staticcall(gas(),EC_ADD,mPtr,0x80,dst,0x40)
        if iszero(l_success) {
          error_ec_op()
        }
      }

      /// @param dst pointer storing the result
      /// @param p pointer to the first point (calldata)
      /// @param q pointer to the second point (calladata)
      /// @param mPtr pointer to free memory
      function point_add_calldata(dst, p, q, mPtr) {
        mstore(mPtr, mload(p))
        mstore(add(mPtr, 0x20), mload(add(p, 0x20)))
        mstore(add(mPtr, 0x40), calldataload(q))
        mstore(add(mPtr, 0x60), calldataload(add(q, 0x20)))
        let l_success := staticcall(gas(), EC_ADD, mPtr, 0x80, dst, 0x40)
        if iszero(l_success) {
          error_ec_op()
        }
      }

      /// @parma dst pointer storing the result
      /// @param src pointer to a point on Bn254(ùîΩ_p)
      /// @param s scalar
      /// @param mPtr free memory
      function point_mul(dst,src,s, mPtr) {
        mstore(mPtr,mload(src))
        mstore(add(mPtr,0x20),mload(add(src,0x20)))
        mstore(add(mPtr,0x40),s)
        let l_success := staticcall(gas(),EC_MUL,mPtr,0x60,dst,0x40)
        if iszero(l_success) {
          error_ec_op()
        }
      }

      /// @parma dst pointer storing the result
      /// @param src pointer to a point on Bn254(ùîΩ_p) on calldata
      /// @param s scalar
      /// @param mPtr free memory
      function point_mul_calldata(dst, src, s, mPtr) {
        mstore(mPtr, calldataload(src))
        mstore(add(mPtr, 0x20), calldataload(add(src, 0x20)))
        mstore(add(mPtr, 0x40), s)
        let l_success := staticcall(gas(), EC_MUL, mPtr, 0x60, dst, 0x40)
        if iszero(l_success) {
          error_ec_op()
        }
      }

      /// @notice dst <- dst + [s]src (Elliptic curve)
      /// @param dst pointer accumulator point storing the result
      /// @param src pointer to the point to multiply and add
      /// @param s scalar
      /// @param mPtr free memory
      function point_acc_mul(dst,src,s, mPtr) {
        mstore(mPtr,mload(src))
        mstore(add(mPtr,0x20),mload(add(src,0x20)))
        mstore(add(mPtr,0x40),s)
        let l_success := staticcall(gas(),7,mPtr,0x60,mPtr,0x40)
        mstore(add(mPtr,0x40),mload(dst))
        mstore(add(mPtr,0x60),mload(add(dst,0x20)))
        l_success := and(l_success, staticcall(gas(),EC_ADD,mPtr,0x80,dst, 0x40))
        if iszero(l_success) {
          error_ec_op()
        }
      }

      /// @notice dst <- dst + [s]src (Elliptic curve)
      /// @param dst pointer accumulator point storing the result
      /// @param src pointer to the point to multiply and add (on calldata)
      /// @param s scalar
      /// @mPtr free memory
      function point_acc_mul_calldata(dst, src, s, mPtr) {
        mstore(mPtr, calldataload(src))
        mstore(add(mPtr, 0x20), calldataload(add(src, 0x20)))
        mstore(add(mPtr, 0x40), s)
        let l_success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)
        mstore(add(mPtr, 0x40), mload(dst))
        mstore(add(mPtr, 0x60), mload(add(dst, 0x20)))
        l_success := and(l_success, staticcall(gas(), EC_ADD, mPtr, 0x80, dst, 0x40))
        if iszero(l_success) {
          error_ec_op()
        }
      }

      /// @notice dst <- dst + src*s (Fr) dst,src are addresses, s is a value
      /// @param dst pointer storing the result
      /// @param src pointer to the scalar to multiply and add (on calldata)
      /// @param s scalar
      function fr_acc_mul_calldata(dst, src, s) {
        let tmp :=  mulmod(calldataload(src), s, R_MOD)
        mstore(dst, addmod(mload(dst), tmp, R_MOD))
      }

      /// @param x element to exponentiate
      /// @param e exponent
      /// @param mPtr free memory
      /// @return res x ** e mod r
      function pow(x, e, mPtr)->res {
        mstore(mPtr, 0x20)
        mstore(add(mPtr, 0x20), 0x20)
        mstore(add(mPtr, 0x40), 0x20)
        mstore(add(mPtr, 0x60), x)
        mstore(add(mPtr, 0x80), e)
        mstore(add(mPtr, 0xa0), R_MOD)
        let check_staticcall := staticcall(gas(),MOD_EXP,mPtr,0xc0,mPtr,0x20)
        if eq(check_staticcall, 0) {
            error_mod_exp()
        }
        res := mload(mPtr)
      }
    }
  }

	function getConfig() external view returns (bytes32) {
		return CHAIN_CONFIG;
  }
}
