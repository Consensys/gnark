package test

import (
	"fmt"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/backend"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/scs"
	"github.com/stretchr/testify/assert"
	"math/big"
	"testing"

	"github.com/consensys/gnark/backend/plonk"
)

type commitmentCircuit struct {
	Public []frontend.Variable `gnark:",public"`
	X      []frontend.Variable
}

func (c *commitmentCircuit) Define(api frontend.API) error {

	commitment, err := tryCommit(api, c.X...)
	if err != nil {
		return err
	}
	api.AssertIsDifferent(commitment, c.X[0])
	for _, p := range c.Public {
		api.AssertIsDifferent(p, 0)
	}
	return err
}

func (c *commitmentCircuit) hollow() frontend.Circuit {
	return &commitmentCircuit{Public: make([]frontend.Variable, len(c.Public)), X: make([]frontend.Variable, len(c.X))}
}

func TestSingleCommitmentPlonk(t *testing.T) {
	assignment := &commitmentCircuit{X: []frontend.Variable{1}, Public: []frontend.Variable{}}
	plonkTest(t, assignment.hollow(), assignment)
}

func TestSingleCommitmentFuzzer(t *testing.T) {
	assignment := &commitmentCircuit{X: []frontend.Variable{1}, Public: []frontend.Variable{}}
	NewAssert(t).ProverSucceeded(assignment.hollow(), assignment, WithCurves(ecc.BN254), WithBackends(backend.GROTH16)) // TODO: Make generic
}

func TestFiveCommitmentsPlonk(t *testing.T) {
	assignment := &commitmentCircuit{X: []frontend.Variable{1, 2, 3, 4, 5}, Public: []frontend.Variable{}}
	plonkTest(t, assignment.hollow(), assignment)
}

func TestSingleCommitmentSinglePublicPlonk(t *testing.T) {
	assignment := &commitmentCircuit{X: []frontend.Variable{0}, Public: []frontend.Variable{1}}
	plonkTest(t, assignment.hollow(), assignment)
}

func TestFiveCommitmentsFivePublicPlonk(t *testing.T) {
	assignment := &commitmentCircuit{X: []frontend.Variable{0, 1, 2, 3, 4}, Public: []frontend.Variable{1, 2, 3, 4, 5}}
	plonkTest(t, assignment.hollow(), assignment)
}

type noCommitmentCircuit struct {
	X frontend.Variable
}

func (c *noCommitmentCircuit) Define(api frontend.API) error {
	api.AssertIsEqual(c.X, 1)
	api.AssertIsEqual(c.X, 1)
	return nil
}

func TestNoCommitmentCircuitPlonk(t *testing.T) {
	plonkTest(t, &noCommitmentCircuit{}, &noCommitmentCircuit{1})
}

var fr = []ecc.ID{
	ecc.BN254,
	ecc.BLS12_381,
	ecc.BLS12_377,
	ecc.BLS24_315,
	//ecc.BLS12_378, TODO: @Tabaie Not autogenerated?
	ecc.BLS24_317,
	ecc.BW6_633,
	//ecc.BW6_756, TODO: @Tabaie Not autogenerated?
	ecc.BW6_761,
}

func plonkTest(t *testing.T, circuit, assignment frontend.Circuit) {

	run := func(mod *big.Int) func(t *testing.T) {
		return func(t *testing.T) {
			ccs, err := frontend.Compile(mod, scs.NewBuilder, circuit)
			assert.NoError(t, err)

			witnessFull, err := frontend.NewWitness(assignment, mod)
			assert.NoError(t, err)
			witnessPublic, err := witnessFull.Public()
			assert.NoError(t, err)

			srs, err := NewKZGSRS(ccs)
			assert.NoError(t, err)

			pk, vk, err := plonk.Setup(ccs, srs)
			assert.NoError(t, err)

			proof, err := plonk.Prove(ccs, pk, witnessFull)
			assert.NoError(t, err)

			err = plonk.Verify(proof, vk, witnessPublic)
			assert.NoError(t, err)
		}
	}

	for _, id := range fr {
		t.Run(id.String(), run(id.ScalarField()))
	}
}

type committedConstantCircuit struct {
	X frontend.Variable
}

func (c *committedConstantCircuit) Define(api frontend.API) error {
	commitment, err := tryCommit(api, 1, c.X)
	if err != nil {
		return err
	}
	api.AssertIsDifferent(commitment, c.X)
	return nil
}

func TestCommittedConstant(t *testing.T) {
	plonkTest(t, &committedConstantCircuit{}, &committedConstantCircuit{1})
}

type committedPublicCircuit struct {
	X frontend.Variable `gnark:",public"`
}

func (c *committedPublicCircuit) Define(api frontend.API) error {
	commitment, err := tryCommit(api, c.X)
	if err != nil {
		return err
	}
	api.AssertIsDifferent(commitment, c.X)
	return nil
}

func TestCommittedPublic(t *testing.T) {
	plonkTest(t, &committedPublicCircuit{}, &committedPublicCircuit{1})
}

func tryCommit(api frontend.API, x ...frontend.Variable) (frontend.Variable, error) {
	committer, ok := api.(frontend.Committer)
	if !ok {
		return nil, fmt.Errorf("type %T doesn't impl the Committer interface", api)
	}
	return committer.Commit(x...)
}
