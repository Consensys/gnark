package gpoint

// Src is the aggregated source code
var Src []string

// Tst is the aggregated test code
var Tst []string

func init() {
	Src = []string{
		base,
		add,
		addMixed,
		double,
		scalarMul,
		multiExp,
		windowedMultiExp,
	}

	Tst = []string{
		tests,
		benchmarks,
	}
}

const base = `
// Code generated by internal/gpoint DO NOT EDIT 

// Most algos for points operations are taken from http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html

package {{.PackageName}}

import (
	{{if eq .CType "fp.Element"}}
		"github.com/consensys/gnark/ecc/{{.PackageName}}/fp"
	{{end}}
	"github.com/consensys/gnark/ecc/{{.PackageName}}/fr"
	"github.com/consensys/gnark/internal/pool"
	"github.com/consensys/gnark/internal/debug"
	"sync"
)

// {{.Name}}Jac is a point with {{.CType}} coordinates
type {{.Name}}Jac struct {
	X, Y, Z {{.CType}}
}

// {{.Name}}Affine point in affine coordinates
type {{.Name}}Affine struct {
	X, Y {{.CType}}
}

// {{toLower .Name}}JacExtended parameterized jacobian coordinates (x=X/ZZ, y=Y/ZZZ, ZZ**3=ZZZ**2)
type {{toLower .Name}}JacExtended struct {
	X, Y, ZZ, ZZZ {{.CType}}
}

// SetInfinity sets p to O
func (p *{{toLower .Name}}JacExtended) SetInfinity() *{{toLower .Name}}JacExtended {
	p.X.SetOne()
	p.Y.SetOne()
	p.ZZ.SetZero()
	p.ZZZ.SetZero()
	return p
}

// ToAffine sets p in affine coords
func (p *{{toLower .Name}}JacExtended) ToAffine(Q *{{.Name}}Affine) *{{.Name}}Affine {
	Q.X.Inverse(&p.ZZ).MulAssign(&p.X)
	Q.Y.Inverse(&p.ZZZ).MulAssign(&p.Y)
	return Q
}

// ToJac sets p in affine coords
func (p *{{toLower .Name}}JacExtended) ToJac(Q *{{.Name}}Jac) *{{.Name}}Jac {
	Q.X.Mul(&p.ZZ, &p.X).MulAssign(&p.ZZ)
	Q.Y.Mul(&p.ZZZ, &p.Y).MulAssign(&p.ZZZ)
	Q.Z.Set(&p.ZZZ)
	return Q
}

// mAdd
// http://www.hyperelliptic.org/EFD/{{toLower .Name}}p/auto-shortw-xyzz.html#addition-madd-2008-s
func (p *{{toLower .Name}}JacExtended) mAdd(a *{{.Name}}Affine) *{{toLower .Name}}JacExtended {

	//if a is infinity return p
	if a.X.IsZero() && a.Y.IsZero() {
		return p
	}
	// p is infinity, return a
	if p.ZZ.IsZero() {
		p.X = a.X
		p.Y = a.Y
		p.ZZ.SetOne()
		p.ZZZ.SetOne()
		return p
	}

	var U2, S2, P, R, PP, PPP, Q, Q2, RR, X3, Y3 {{.CType}}

	// p2: a, p1: p
	U2.Mul(&a.X, &p.ZZ)
	S2.Mul(&a.Y, &p.ZZZ)
	if U2.Equal(&p.X) && S2.Equal(&p.Y) {
		return p.double(a)
	}
	P.Sub(&U2, &p.X)
	R.Sub(&S2, &p.Y)
	PP.Square(&P)
	PPP.Mul(&P, &PP)
	Q.Mul(&p.X, &PP)
	RR.Square(&R)
	X3.Sub(&RR, &PPP)
	Q2.AddAssign(&Q).AddAssign(&Q)
	p.X.Sub(&X3, &Q2)
	Y3.Sub(&Q, &p.X).MulAssign(&R)
	R.Mul(&p.Y, &PPP)
	p.Y.Sub(&Y3, &R)
	p.ZZ.MulAssign(&PP)
	p.ZZZ.MulAssign(&PPP)

	return p
}

// double point in ZZ coords
// http://www.hyperelliptic.org/EFD/{{toLower .Name}}p/auto-shortw-xyzz.html#doubling-dbl-2008-s-1
func (p *{{toLower .Name}}JacExtended) double(q *{{.Name}}Affine) *{{toLower .Name}}JacExtended {

	var U, S, M, _M, Y3 {{.CType}}

	U.Double(&q.Y)
	p.ZZ.Square(&U)
	p.ZZZ.Mul(&U, &p.ZZ)
	S.Mul(&q.X, &p.ZZ)
	_M.Square(&q.X)
	M.Double(&_M).
		AddAssign(&_M) // -> + a, but a=0 here
	p.X.Square(&M).
		SubAssign(&S).
		SubAssign(&S)
	Y3.Sub(&S, &p.X).MulAssign(&M)
	U.Mul(&p.ZZZ, &q.Y)
	p.Y.Sub(&Y3, &U)

	return p
}

// Set set p to the provided point
func (p *{{.Name}}Jac) Set(a *{{.Name}}Jac) *{{.Name}}Jac {
	p.X.Set(&a.X)
	p.Y.Set(&a.Y)
	p.Z.Set(&a.Z)
	return p
}

// Equal tests if two points (in Jacobian coordinates) are equal
func (p *{{.Name}}Jac) Equal(a *{{.Name}}Jac) bool {

	if p.Z.IsZero() && a.Z.IsZero() {
		return true
	}
	_p := {{.Name}}Affine{}
	p.ToAffineFromJac(&_p)

	_a := {{.Name}}Affine{}
	a.ToAffineFromJac(&_a)

	return _p.X.Equal(&_a.X) && _p.Y.Equal(&_a.Y)
}

// Equal tests if two points (in Affine coordinates) are equal
func (p *{{ .Name}}Affine) Equal(a *{{ .Name}}Affine) bool {
	return p.X.Equal(&a.X) && p.Y.Equal(&a.Y)
}

// Clone returns a copy of self
func (p *{{.Name}}Jac) Clone() *{{.Name}}Jac {
	return &{{.Name}}Jac{
		p.X, p.Y, p.Z,
	}
}


// Neg computes -G
func (p *{{.Name}}Jac) Neg(a *{{.Name}}Jac) *{{.Name}}Jac {
	p.Set(a)
	p.Y.Neg(&a.Y)
	return p
}

// Neg computes -G
func (p *{{.Name}}Affine) Neg(a *{{.Name}}Affine) *{{.Name}}Affine {
	p.X.Set(&a.X)
	p.Y.Neg(&a.Y)
	return p
}

// Sub substracts two points on the curve
func (p *{{.Name}}Jac) Sub(curve *Curve, a {{.Name}}Jac) *{{.Name}}Jac {
	a.Y.Neg(&a.Y)
	p.Add(curve, &a)
	return p
}

// ToAffineFromJac rescale a point in Jacobian coord in z=1 plane
// WARNING super slow function (due to the division)
func (p *{{.Name}}Jac) ToAffineFromJac(res *{{.Name}}Affine) *{{.Name}}Affine {

	var bufs [3]{{.CType}}

	if p.Z.IsZero() {
		res.X.SetZero()
		res.Y.SetZero()
		return res
	}

	bufs[0].Inverse(&p.Z)
	bufs[2].Square(&bufs[0])
	bufs[1].Mul(&bufs[2], &bufs[0])

	res.Y.Mul(&p.Y, &bufs[1])
	res.X.Mul(&p.X, &bufs[2])

	return res
}

// ToProjFromJac converts a point from Jacobian to projective coordinates
func (p *{{.Name}}Jac) ToProjFromJac() *{{.Name}}Jac {
	// memalloc
	var buf {{.CType}}
	buf.Square(&p.Z)

	p.X.Mul(&p.X, &p.Z)
	p.Z.Mul(&p.Z, &buf)

	return p
}

func (p *{{.Name}}Jac) String(curve *Curve) string {
	if p.Z.IsZero() {
		return "O"
	}
	_p := {{.Name}}Affine{}
	p.ToAffineFromJac(&_p)
	_p.X.FromMont()
	_p.Y.FromMont()
	return "E([" + _p.X.String() + "," + _p.Y.String() + "]),"
}

// ToJacobian sets Q = p, Q in Jacboian, p in affine
func (p *{{ .Name}}Affine) ToJacobian(Q *{{ .Name}}Jac) *{{ .Name}}Jac {
	if p.X.IsZero() && p.Y.IsZero() {
		Q.Z.SetZero()
		Q.X.SetOne()
		Q.Y.SetOne()
		return Q
	}
	Q.Z.SetOne()
	Q.X.Set(&p.X)
	Q.Y.Set(&p.Y)
	return Q
}

func (p *{{.Name}}Affine) String(curve *Curve) string {
	var x, y {{.CType}}
	x.Set(&p.X)
	y.Set(&p.Y)
	return "E([" + x.FromMont().String() + "," + y.FromMont().String() + "]),"
}

// IsInfinity checks if the point is infinity (in affine, it's encoded as (0,0))
func (p *{{.Name}}Affine) IsInfinity() bool {
	return p.X.IsZero() && p.Y.IsZero()
}
`
