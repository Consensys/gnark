// partially derived from: https://github.com/pkg/profile
// Original copyright:
// Copyright (c) 2013 Dave Cheney. All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:

//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package profile

import (
	"io/ioutil"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"

	"github.com/consensys/gnark/logger"
	"github.com/google/pprof/profile"
)

// Profile represents an active constraint system profiling session.
type Profile struct {
	// path holds the base path where various profiling files are  written.
	// If blank, the base path will be generated by ioutil.TempDir.
	path string

	// closer holds a cleanup function that run after each profile
	closer func()

	// stopped records if a call to profile.Stop has been made
	stopped uint32

	// noShutdownHook controls whether the profiling package should
	// hook SIGINT to write profiles cleanly.
	noShutdownHook bool

	// actual pprof profile struct
	pprof profile.Profile

	functions map[string]*profile.Function
	locations map[uint64]*profile.Location

	onceSetName sync.Once
}

// NoShutdownHook controls whether the profiling package should
// hook SIGINT to write profiles cleanly.
// Programs with more sophisticated signal handling should set
// this to true and ensure the Stop() function returned from Start()
// is called during shutdown.
func NoShutdownHook(p *Profile) { p.noShutdownHook = true }

// ProfilePath controls the base path where various profiling
// files are written. If blank, the base path will be generated
// by ioutil.TempDir.
func ProfilePath(path string) func(*Profile) {
	return func(p *Profile) {
		p.path = path
	}
}

func (p *Profile) Stop() {
	if !atomic.CompareAndSwapUint32(&p.stopped, 0, 1) {
		// someone has already called close
		return
	}
	p.closer()
	atomic.StoreUint32(&started, 0)
}

// started is non zero if a profile is running.
var started uint32

// this is a global var, need to improve that;
// not a big risk given than circuit compilation runs in a single go routine, but ... ugly.
var _profile *Profile

func Start(options ...func(*Profile)) interface {
	Stop()
} {
	log := logger.Logger()
	if !atomic.CompareAndSwapUint32(&started, 0, 1) {
		log.Fatal().Msg("Start() already called")
	}
	prof := Profile{
		functions: make(map[string]*profile.Function),
		locations: make(map[uint64]*profile.Location),
	}
	for _, option := range options {
		option(&prof)
	}

	path, err := func() (string, error) {
		if p := prof.path; p != "" {
			return p, os.MkdirAll(p, 0777)
		}
		return ioutil.TempDir("", "profile")
	}()

	if err != nil {
		log.Fatal().Err(err).Msg("could not create initial output directory")
	}

	fn := filepath.Join(path, "gnark.pprof")
	f, err := os.Create(fn)
	if err != nil {
		log.Fatal().Err(err).Msg("could not create gnark profile")
	}
	log.Debug().Msgf("gnark profiling enabled, %s", fn)

	prof.pprof.SampleType = []*profile.ValueType{{
		Type: "constraints",
		Unit: "count",
	}}

	prof.closer = func() {
		if err := prof.pprof.Write(f); err != nil {
			log.Error().Err(err).Msg("writing profile")
		}
		f.Close()
		log.Debug().Msgf("gnark profiling disabled, %s", fn)
	}

	if !prof.noShutdownHook {
		go func() {
			c := make(chan os.Signal, 1)
			signal.Notify(c, os.Interrupt)
			<-c

			log.Info().Msg("caught interrupt, stopping profiles")
			prof.Stop()

			os.Exit(0)
		}()
	}

	_profile = &prof
	return &prof
}

func Sample() {
	if s := atomic.LoadUint32(&started); s == 0 {
		return // do nothing, no profile running.
	}

	sample := &profile.Sample{
		Value: []int64{1},
	}

	// 1 collect the stack .
	// Ask runtime.Callers for up to 10 pcs
	pc := make([]uintptr, 20)
	n := runtime.Callers(3, pc)
	if n == 0 {
		// No pcs available. Stop now.
		// This can happen if the first argument to runtime.Callers is large.
		return
	}
	pc = pc[:n] // pass only valid pcs to runtime.CallersFrames
	frames := runtime.CallersFrames(pc)
	// Loop to get frames.
	// A fixed number of pcs can expand to an indefinite number of Frames.
	for {
		frame, more := frames.Next()
		if strings.HasSuffix(frame.Function, ".func1") {
			// TODO @gbotrel filter lambda func better
			continue
		}

		// TODO @gbotrel [...] -> from generics display poorly in pprof
		// fix may be coming in go 1.19
		frame.Function = strings.Replace(frame.Function, "[...]", "[T]", -1)

		sample.Location = append(sample.Location, _profile.getLocation(&frame))

		if !more {
			break
		}
		if strings.HasSuffix(frame.Function, "Define") {
			_profile.onceSetName.Do(func() {
				fe := strings.Split(frame.Function, "/")
				circuitName := strings.TrimSuffix(fe[len(fe)-1], ".Define")
				_profile.pprof.Mapping = []*profile.Mapping{
					{ID: 1, File: circuitName},
				}
			})
			break
		}
	}

	_profile.pprof.Sample = append(_profile.pprof.Sample, sample)
}

func (p *Profile) getLocation(frame *runtime.Frame) *profile.Location {

	// location
	// locationID := frame.File + strconv.Itoa(frame.Line)
	l, ok := p.locations[uint64(frame.PC)]
	if !ok {
		// first let's see if we have the function.
		f, ok := p.functions[frame.File+frame.Function]
		if !ok {
			fe := strings.Split(frame.Function, "/")
			fName := fe[len(fe)-1]
			f = &profile.Function{
				ID:         uint64(len(p.functions) + 1),
				Name:       fName,
				SystemName: frame.Function,
				Filename:   frame.File,
			}

			p.functions[frame.File+frame.Function] = f
			p.pprof.Function = append(p.pprof.Function, f)
		}

		l = &profile.Location{
			ID:   uint64(len(p.locations) + 1),
			Line: []profile.Line{{Function: f, Line: int64(frame.Line)}},
		}
		p.locations[uint64(frame.PC)] = l
		p.pprof.Location = append(p.pprof.Location, l)
	}

	return l
}
