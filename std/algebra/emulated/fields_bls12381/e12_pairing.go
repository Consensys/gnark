package fields_bls12381

import "github.com/consensys/gnark/std/math/emulated"

func (e Ext12) nSquareGS(z *E12, n int) *E12 {
	for i := 0; i < n; i++ {
		z = e.CyclotomicSquare(z)
	}
	return z
}

// Expt sets z to x^t in E12 and return z
// where t = -u = 15132376222941642752
func (e Ext12) Expt(x *E12) *E12 {
	// Expt computation is derived from the addition chain:
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_1100    = _11 << 2
	//	_1101    = 1 + _1100
	//	_1101000 = _1101 << 3
	//	_1101001 = 1 + _1101000
	//	return     ((_1101001 << 9 + 1) << 32 + 1) << 15
	//
	// Operations: 62 squares 5 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	z := e.CyclotomicSquare(x)
	z = e.Mul(x, z)
	z = e.nSquareGS(z, 2)
	z = e.Mul(x, z)
	z = e.nSquareGS(z, 3)
	z = e.Mul(x, z)
	z = e.nSquareGS(z, 9)
	z = e.Mul(x, z)
	z = e.nSquareGS(z, 32)
	z = e.Mul(x, z)
	z = e.nSquareGS(z, 15)
	z = e.CyclotomicSquare(z)

	return z
}

// ExpByU sets z to x^U in E12 and return z
// where U = (u-1)^2/3 = 76329603384216526031706109802092473003
func (e Ext12) ExpByU(x *E12) *E12 {
	// ExpByU computation is derived from the addition chain:
	//
	//	_10       = 2*1
	//	_11       = 1 + _10
	//	_110      = 2*_11
	//	_111      = 1 + _110
	//	_1000     = 1 + _111
	//	_100000   = _1000 << 2
	//	_100011   = _11 + _100000
	//	_101010   = _111 + _100011
	//	_1010100  = 2*_101010
	//	_1010101  = 1 + _1010100
	//	_1010110  = 1 + _1010101
	//	_1011001  = _11 + _1010110
	//	_1100001  = _1000 + _1011001
	//	_10101011 = _1010101 + _1010110
	//	_11000010 = 2*_1100001
	//	_11100101 = _100011 + _11000010
	//	i49       = ((_11100101 << 7 + _1011001) << 5 + _11) << 18
	//	i68       = ((_1010101 + i49) << 9 + _10101011) << 7 + _1100001
	//	i85       = (i68 << 9 + _10 + _10101011) << 5 + _11
	//	i136      = ((i85 << 17 + _1010101) << 9 + _10101011) << 23
	//	return      (_1010101 + i136) << 9 + _10101011
	//
	// Operations: 124 squares 23 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	t2 := e.CyclotomicSquare(x)
	t1 := e.Mul(x, t2)
	z := e.CyclotomicSquare(t1)
	z = e.Mul(x, z)
	t3 := e.Mul(x, z)
	t0 := e.CyclotomicSquare(t3)
	t0 = e.CyclotomicSquare(t0)
	t5 := e.Mul(t1, t0)
	z = e.Mul(z, t5)
	z = e.CyclotomicSquare(z)
	t0 = e.Mul(x, z)
	z = e.Mul(x, t0)
	t4 := e.Mul(t1, z)
	t3 = e.Mul(t3, t4)
	z = e.Mul(t0, z)
	t6 := e.CyclotomicSquare(t3)
	t5 = e.Mul(t5, t6)
	t5 = e.nSquareGS(t5, 7)
	t4 = e.Mul(t4, t5)
	t4 = e.nSquareGS(t4, 5)
	t4 = e.Mul(t1, t4)
	t4 = e.nSquareGS(t4, 18)
	t4 = e.Mul(t0, t4)
	t4 = e.nSquareGS(t4, 9)
	t4 = e.Mul(z, t4)
	t4 = e.nSquareGS(t4, 7)
	t3 = e.Mul(t3, t4)
	t3 = e.nSquareGS(t3, 9)
	t2 = e.Mul(t2, t3)
	t2 = e.Mul(z, t2)
	t2 = e.nSquareGS(t2, 5)
	t1 = e.Mul(t1, t2)
	t1 = e.nSquareGS(t1, 17)
	t1 = e.Mul(t0, t1)
	t1 = e.nSquareGS(t1, 9)
	t1 = e.Mul(z, t1)
	t1 = e.nSquareGS(t1, 23)
	t0 = e.Mul(t0, t1)
	t0 = e.nSquareGS(t0, 9)
	z = e.Mul(z, t0)

	return z
}

func (e Ext12) nSquareTorus(z *E6, n int) *E6 {
	for i := 0; i < n; i++ {
		z = e.SquareTorus(z)
	}
	return z
}

// ExptHalfTorus set z to x^(t/2) in E6 and return z
// const t/2 uint64 = 7566188111470821376 // negative
func (e Ext12) ExptHalfTorus(x *E6) *E6 {
	// FixedExp computation is derived from the addition chain:
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_1100    = _11 << 2
	//	_1101    = 1 + _1100
	//	_1101000 = _1101 << 3
	//	_1101001 = 1 + _1101000
	//	return     ((_1101001 << 9 + 1) << 32 + 1) << 15
	//
	// Operations: 62 squares 5 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Step 1: z = x^0x2
	z := e.SquareTorus(x)

	// Step 2: z = x^0x3
	z = e.MulTorus(x, z)

	z = e.SquareTorus(z)
	z = e.SquareTorus(z)

	// Step 5: z = x^0xd
	z = e.MulTorus(x, z)

	// Step 8: z = x^0x68
	z = e.nSquareTorus(z, 3)

	// Step 9: z = x^0x69
	z = e.MulTorus(x, z)

	// Step 18: z = x^0xd200
	z = e.nSquareTorus(z, 9)

	// Step 19: z = x^0xd201
	z = e.MulTorus(x, z)

	// Step 51: z = x^0xd20100000000
	z = e.nSquareTorus(z, 32)

	// Step 52: z = x^0xd20100000001
	z = e.MulTorus(x, z)

	// Step 67: z = x^0x6900800000008000
	z = e.nSquareTorus(z, 15)

	z = e.InverseTorus(z) // because tAbsVal is negative

	return z
}

// ExptTorus set z to xᵗ in E6 and return z
// const t uint64 = 15132376222941642752 // negative
func (e Ext12) ExptTorus(x *E6) *E6 {
	z := e.ExptHalfTorus(x)
	z = e.SquareTorus(z)
	return z
}

// MulBy014 multiplies z by an E12 sparse element of the form
//
//	E12{
//		C0: E6{B0: c0, B1: c1, B2: 0},
//		C1: E6{B0: 0, B1: 1, B2: 0},
//	}
func (e *Ext12) MulBy014(z *E12, c0, c1 *E2) *E12 {

	a := e.MulBy01(&z.C0, c0, c1)

	var b E6
	// Mul by E6{0, 1, 0}
	b.B0 = *e.Ext2.MulByNonResidue(&z.C1.B2)
	b.B2 = z.C1.B1
	b.B1 = z.C1.B0

	one := e.Ext2.One()
	d := e.Ext2.Add(c1, one)

	zC1 := e.Ext6.Add(&z.C1, &z.C0)
	zC1 = e.Ext6.MulBy01(zC1, c0, d)
	tmp := e.Ext6.Add(&b, a)
	zC1 = e.Ext6.Sub(zC1, tmp)
	zC0 := e.Ext6.MulByNonResidue(&b)
	zC0 = e.Ext6.Add(zC0, a)

	return &E12{
		C0: *zC0,
		C1: *zC1,
	}
}

//	multiplies two E12 sparse element of the form:
//
//	E12{
//		C0: E6{B0: c0, B1: c1, B2: 0},
//		C1: E6{B0: 0, B1: 1, B2: 0},
//	}
//
// and
//
//	E12{
//		C0: E6{B0: d0, B1: d1, B2: 0},
//		C1: E6{B0: 0, B1: 1, B2: 0},
//	}
func (e Ext12) Mul014By014(d0, d1, c0, c1 *E2) [5]*E2 {
	x0 := e.Ext2.Mul(c0, d0)
	x1 := e.Ext2.Mul(c1, d1)
	x04 := e.Ext2.Add(c0, d0)
	tmp := e.Ext2.Add(c0, c1)
	x01 := e.Ext2.Add(d0, d1)
	x01 = e.Ext2.Mul(x01, tmp)
	tmp = e.Ext2.Add(x1, x0)
	x01 = e.Ext2.Sub(x01, tmp)
	x14 := e.Ext2.Add(c1, d1)

	zC0B0 := e.Ext2.NonResidue()
	zC0B0 = e.Ext2.Add(zC0B0, x0)

	return [5]*E2{zC0B0, x01, x1, x04, x14}
}

// MulBy01245 multiplies z by an E12 sparse element of the form
//
//	E12{
//		C0: E6{B0: c0, B1: c1, B2: c2},
//		C1: E6{B0: 0, B1: c4, B2: c5},
//	}
func (e *Ext12) MulBy01245(z *E12, x [5]*E2) *E12 {
	c0 := &E6{B0: *x[0], B1: *x[1], B2: *x[2]}
	c1 := &E6{B0: *e.Ext2.Zero(), B1: *x[3], B2: *x[4]}
	a := e.Ext6.Add(&z.C0, &z.C1)
	b := e.Ext6.Add(c0, c1)
	a = e.Ext6.Mul(a, b)
	b = e.Ext6.Mul(&z.C0, c0)
	c := e.Ext6.MulBy12(&z.C1, x[3], x[4])
	d := e.Ext6.Add(c, b)
	z1 := e.Ext6.Sub(a, d)
	z0 := e.Ext6.MulByNonResidue(c)
	z0 = e.Ext6.Add(z0, b)
	return &E12{
		C0: *z0,
		C1: *z1,
	}
}

// Torus-based arithmetic:
//
// After the easy part of the final exponentiation the elements are in a proper
// subgroup of Fpk (E12) that coincides with some algebraic tori. The elements
// are in the torus Tk(Fp) and thus in each torus Tk/d(Fp^d) for d|k, d≠k.  We
// take d=6. So the elements are in T2(Fp6).
// Let G_{q,2} = {m ∈ Fq^2 | m^(q+1) = 1} where q = p^6.
// When m.C1 = 0, then m.C0 must be 1 or −1.
//
// We recall the tower construction:
//
//	𝔽p²[u] = 𝔽p/u²+1
//	𝔽p⁶[v] = 𝔽p²/v³-1-u
//	𝔽p¹²[w] = 𝔽p⁶/w²-v

// CompressTorus compresses x ∈ E12 to (x.C0 + 1)/x.C1 ∈ E6
func (e Ext12) CompressTorus(x *E12) *E6 {
	// x ∈ G_{q,2} \ {-1,1}
	y := e.Ext6.Add(&x.C0, e.Ext6.One())
	y = e.Ext6.DivUnchecked(y, &x.C1)
	return y
}

// DecompressTorus decompresses y ∈ E6 to (y+w)/(y-w) ∈ E12
func (e Ext12) DecompressTorus(y *E6) *E12 {
	var n, d E12
	one := e.Ext6.One()
	n.C0 = *y
	n.C1 = *one
	d.C0 = *y
	d.C1 = *e.Ext6.Neg(one)

	x := e.DivUnchecked(&n, &d)
	return x
}

// MulTorus multiplies two compressed elements y1, y2 ∈ E6
// and returns (y1 * y2 + v)/(y1 + y2)
// N.B.: we use MulTorus in the final exponentiation throughout y1 ≠ -y2 always.
func (e Ext12) MulTorus(y1, y2 *E6) *E6 {
	n := e.Ext6.Mul(y1, y2)
	n.B1 = *e.Ext2.Add(&n.B1, e.Ext2.One())
	d := e.Ext6.Add(y1, y2)
	y3 := e.Ext6.DivUnchecked(n, d)
	return y3
}

// InverseTorus inverses a compressed elements y ∈ E6
// and returns -y
func (e Ext12) InverseTorus(y *E6) *E6 {
	return e.Ext6.Neg(y)
}

// SquareTorus squares a compressed elements y ∈ E6
// and returns (y + v/y)/2
//
// It uses a hint to verify that (2x-y)y = v saving one E6 AssertIsEqual.
func (e Ext12) SquareTorus(y *E6) *E6 {
	res, err := e.fp.NewHint(squareTorusHint, 6, &y.B0.A0, &y.B0.A1, &y.B1.A0, &y.B1.A1, &y.B2.A0, &y.B2.A1)
	if err != nil {
		// err is non-nil only for invalid number of inputs
		panic(err)
	}

	sq := E6{
		B0: E2{A0: *res[0], A1: *res[1]},
		B1: E2{A0: *res[2], A1: *res[3]},
		B2: E2{A0: *res[4], A1: *res[5]},
	}

	// v = (2x-y)y
	v := e.Ext6.Double(&sq)
	v = e.Ext6.Sub(v, y)
	v = e.Ext6.Mul(v, y)

	_v := E6{B0: *e.Ext2.Zero(), B1: *e.Ext2.One(), B2: *e.Ext2.Zero()}
	e.Ext6.AssertIsEqual(v, &_v)

	return &sq

}

// FrobeniusTorus raises a compressed elements y ∈ E6 to the modulus p
// and returns y^p / v^((p-1)/2)
func (e Ext12) FrobeniusTorus(y *E6) *E6 {
	t0 := e.Ext2.Conjugate(&y.B0)
	t1 := e.Ext2.Conjugate(&y.B1)
	t2 := e.Ext2.Conjugate(&y.B2)
	t1 = e.Ext2.MulByNonResidue1Power2(t1)
	t2 = e.Ext2.MulByNonResidue1Power4(t2)

	v0 := E2{emulated.ValueOf[emulated.BLS12381Fp]("877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230"), emulated.ValueOf[emulated.BLS12381Fp]("877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230")}
	res := &E6{B0: *t0, B1: *t1, B2: *t2}
	res = e.Ext6.MulBy0(res, &v0)

	return res
}

// FrobeniusSquareTorus raises a compressed elements y ∈ E6 to the square modulus p^2
// and returns y^(p^2) / v^((p^2-1)/2)
func (e Ext12) FrobeniusSquareTorus(y *E6) *E6 {
	v0 := emulated.ValueOf[emulated.BLS12381Fp]("4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437")
	t0 := e.Ext2.MulByElement(&y.B0, &v0)
	t1 := e.Ext2.MulByNonResidue2Power2(&y.B1)
	t1 = e.Ext2.MulByElement(t1, &v0)
	t2 := e.Ext2.MulByNonResidue2Power4(&y.B2)
	t2 = e.Ext2.MulByElement(t2, &v0)

	return &E6{B0: *t0, B1: *t1, B2: *t2}
}

// AssertFinalExponentiationIsOne checks that a Miller function output x lies in the
// same equivalence class as the reduced pairing. This replaces the final
// exponentiation step in-circuit.
// The method is inspired from [On Proving Pairings] paper by A. Novakovic and
// L. Eagen, and is based on a personal communication with A. Novakovic.
//
// [On Proving Pairings]: https://eprint.iacr.org/2024/640.pdf
func (e Ext12) AssertFinalExponentiationIsOne(x *E12) {
	res, err := e.fp.NewHint(finalExpHint, 18, &x.C0.B0.A0, &x.C0.B0.A1, &x.C0.B1.A0, &x.C0.B1.A1, &x.C0.B2.A0, &x.C0.B2.A1, &x.C1.B0.A0, &x.C1.B0.A1, &x.C1.B1.A0, &x.C1.B1.A1, &x.C1.B2.A0, &x.C1.B2.A1)
	if err != nil {
		// err is non-nil only for invalid number of inputs
		panic(err)
	}

	residueWitness := E12{
		C0: E6{
			B0: E2{A0: *res[0], A1: *res[1]},
			B1: E2{A0: *res[2], A1: *res[3]},
			B2: E2{A0: *res[4], A1: *res[5]},
		},
		C1: E6{
			B0: E2{A0: *res[6], A1: *res[7]},
			B1: E2{A0: *res[8], A1: *res[9]},
			B2: E2{A0: *res[10], A1: *res[11]},
		},
	}
	// constrain cubicNonResiduePower to be in Fp6
	scalingFactor := E12{
		C0: E6{
			B0: E2{A0: *res[12], A1: *res[13]},
			B1: E2{A0: *res[14], A1: *res[15]},
			B2: E2{A0: *res[16], A1: *res[17]},
		},
		C1: (*e.Ext6.Zero()),
	}

	// Check that  x * scalingFactor == residueWitness^(q-u)
	// where u=-0xd201000000010000 is the BLS12-381 seed,
	// and residueWitness, scalingFactor from the hint.
	t0 := e.Frobenius(&residueWitness)
	// exponentiation by -u
	t1 := e.Expt(&residueWitness)
	t0 = e.Mul(t0, t1)

	t1 = e.Mul(x, &scalingFactor)

	e.AssertIsEqual(t0, t1)
}

func (e Ext12) Frobenius(x *E12) *E12 {
	t0 := e.Ext2.Conjugate(&x.C0.B0)
	t1 := e.Ext2.Conjugate(&x.C0.B1)
	t2 := e.Ext2.Conjugate(&x.C0.B2)
	t3 := e.Ext2.Conjugate(&x.C1.B0)
	t4 := e.Ext2.Conjugate(&x.C1.B1)
	t5 := e.Ext2.Conjugate(&x.C1.B2)
	t1 = e.Ext2.MulByNonResidue1Power2(t1)
	t2 = e.Ext2.MulByNonResidue1Power4(t2)
	t3 = e.Ext2.MulByNonResidue1Power1(t3)
	t4 = e.Ext2.MulByNonResidue1Power3(t4)
	t5 = e.Ext2.MulByNonResidue1Power5(t5)
	return &E12{
		C0: E6{
			B0: *t0,
			B1: *t1,
			B2: *t2,
		},
		C1: E6{
			B0: *t3,
			B1: *t4,
			B2: *t5,
		},
	}
}

func (e Ext12) FrobeniusSquare(x *E12) *E12 {
	z00 := &x.C0.B0
	z01 := e.Ext2.MulByNonResidue2Power2(&x.C0.B1)
	z02 := e.Ext2.MulByNonResidue2Power4(&x.C0.B2)
	z10 := e.Ext2.MulByNonResidue2Power1(&x.C1.B0)
	z11 := e.Ext2.MulByNonResidue2Power3(&x.C1.B1)
	z12 := e.Ext2.MulByNonResidue2Power5(&x.C1.B2)
	return &E12{
		C0: E6{B0: *z00, B1: *z01, B2: *z02},
		C1: E6{B0: *z10, B1: *z11, B2: *z12},
	}
}
