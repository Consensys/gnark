package fields_bn254

func (e Ext12) Expt(x *E12) *E12 {
	// Expt computation is derived from the addition chain:
	//
	//	_10     = 2*1
	//	_100    = 2*_10
	//	_1000   = 2*_100
	//	_10000  = 2*_1000
	//	_10001  = 1 + _10000
	//	_10011  = _10 + _10001
	//	_10100  = 1 + _10011
	//	_11001  = _1000 + _10001
	//	_100010 = 2*_10001
	//	_100111 = _10011 + _10100
	//	_101001 = _10 + _100111
	//	i27     = (_100010 << 6 + _100 + _11001) << 7 + _11001
	//	i44     = (i27 << 8 + _101001 + _10) << 6 + _10001
	//	i70     = ((i44 << 8 + _101001) << 6 + _101001) << 10
	//	return    (_100111 + i70) << 6 + _101001 + _1000
	//
	// Operations: 62 squares 17 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	t3 := e.CyclotomicSquare(x)
	t5 := e.CyclotomicSquare(t3)
	result := e.CyclotomicSquare(t5)
	t0 := e.CyclotomicSquare(result)
	t2 := e.Mul(x, t0)
	t0 = e.Mul(t3, t2)
	t1 := e.Mul(x, t0)
	t4 := e.Mul(result, t2)
	t6 := e.CyclotomicSquare(t2)
	t1 = e.Mul(t0, t1)
	t0 = e.Mul(t3, t1)
	t6 = e.NCycloSquareCompressed(t6, 6)
	t6 = e.DecompressKarabina(t6)
	t5 = e.Mul(t5, t6)
	t5 = e.Mul(t4, t5)
	t5 = e.NCycloSquareCompressed(t5, 7)
	t5 = e.DecompressKarabina(t5)
	t4 = e.Mul(t4, t5)
	t4 = e.NCycloSquareCompressed(t4, 8)
	t4 = e.DecompressKarabina(t4)
	t4 = e.Mul(t0, t4)
	t3 = e.Mul(t3, t4)
	t3 = e.NCycloSquareCompressed(t3, 6)
	t3 = e.DecompressKarabina(t3)
	t2 = e.Mul(t2, t3)
	t2 = e.NCycloSquareCompressed(t2, 8)
	t2 = e.DecompressKarabina(t2)
	t2 = e.Mul(t0, t2)
	t2 = e.NCycloSquareCompressed(t2, 6)
	t2 = e.DecompressKarabina(t2)
	t2 = e.Mul(t0, t2)
	t2 = e.NCycloSquareCompressed(t2, 10)
	t2 = e.DecompressKarabina(t2)
	t1 = e.Mul(t1, t2)
	t1 = e.NCycloSquareCompressed(t1, 6)
	t1 = e.DecompressKarabina(t1)
	t0 = e.Mul(t0, t1)
	z := e.Mul(result, t0)
	return z
}

// MulBy034 multiplies z by an E12 sparse element of the form
//
//	E12{
//		C0: E6{B0: 1, B1: 0, B2: 0},
//		C1: E6{B0: c3, B1: c4, B2: 0},
//	}
func (e *Ext12) MulBy034(z *E12, c3, c4 *E2) *E12 {

	a := z.C0
	b := z.C1
	b = *e.MulBy01(&b, c3, c4)
	c3 = e.Ext2.Add(e.Ext2.One(), c3)
	d := e.Ext6.Add(&z.C0, &z.C1)
	d = e.MulBy01(d, c3, c4)

	zC1 := e.Ext6.Add(&a, &b)
	zC1 = e.Ext6.Neg(zC1)
	zC1 = e.Ext6.Add(zC1, d)
	zC0 := e.Ext6.MulByNonResidue(&b)
	zC0 = e.Ext6.Add(zC0, &a)

	return &E12{
		C0: *zC0,
		C1: *zC1,
	}
}

//	multipliies two E12 sparse element of the form:
//
//	E12{
//		C0: E6{B0: 1, B1: 0, B2: 0},
//		C1: E6{B0: c3, B1: c4, B2: 0},
//	}
//
// and
//
//	E12{
//		C0: E6{B0: 1, B1: 0, B2: 0},
//		C1: E6{B0: d3, B1: d4, B2: 0},
//	}
func (e *Ext12) Mul034By034(d3, d4, c3, c4 *E2) *E12 {
	x3 := e.Ext2.Mul(c3, d3)
	x4 := e.Ext2.Mul(c4, d4)
	x04 := e.Ext2.Add(c4, d4)
	x03 := e.Ext2.Add(c3, d3)
	tmp := e.Ext2.Add(c3, c4)
	x34 := e.Ext2.Add(d3, d4)
	x34 = e.Ext2.Mul(x34, tmp)
	x34 = e.Ext2.Sub(x34, x3)
	x34 = e.Ext2.Sub(x34, x4)

	zC0B0 := e.Ext2.MulByNonResidue(x4)
	zC0B0 = e.Ext2.Add(zC0B0, e.Ext2.One())
	zC0B1 := x3
	zC0B2 := x34
	zC1B0 := x03
	zC1B1 := x04
	zC1B2 := e.Ext2.Zero()

	return &E12{
		C0: E6{
			B0: *zC0B0, B1: *zC0B1, B2: *zC0B2,
		},
		C1: E6{
			B0: *zC1B0, B1: *zC1B1, B2: *zC1B2,
		},
	}
}

// MulBy01234 multiplies z by an E12 sparse element of the form
//
//	E12{
//		C0: E6{B0: c0, B1: c1, B2: c2},
//		C1: E6{B0: c3, B1: c4, B2: 0},
//	}
func (e *Ext12) MulBy01234(z *E12, b0, b1, b2, b3, b4 *E2) *E12 {
	c0 := &E6{B0: *b0, B1: *b1, B2: *b2}
	c1 := &E6{B0: *b3, B1: *b4, B2: *e.Ext2.Zero()}
	a := e.Ext6.Add(&z.C0, &z.C1)
	b := e.Ext6.Add(c0, c1)
	a = e.Ext6.Mul(a, b)
	b = e.Ext6.Mul(&z.C0, c0)
	c := e.Ext6.MulBy01(&z.C1, b3, b4)
	z1 := e.Ext6.Sub(a, b)
	z1 = e.Ext6.Sub(z1, c)
	z0 := e.Ext6.MulByNonResidue(c)
	z0 = e.Ext6.Add(z0, b)
	return &E12{
		C0: *z0,
		C1: *z1,
	}
}
