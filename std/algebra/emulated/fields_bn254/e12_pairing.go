package fields_bn254

import (
	"math/big"
)

func (e Ext12) nSquareGS(z *E12, n int) *E12 {
	for i := 0; i < n; i++ {
		z = e.CyclotomicSquareGS(z)
	}
	return z
}

// Exponentiation by U=6u+2 where t is the seed u=4965661367192848881
func (e Ext12) ExpByU(x *E12) *E12 {
	// ExpByU computation is derived from the addition chain:
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_110     = 2*_11
	//	_111     = 1 + _110
	//	_1100    = 2*_110
	//	_1111    = _11 + _1100
	//	_1100000 = _1100 << 3
	//	_1100111 = _111 + _1100000
	//	i22      = ((_1100111 << 2 + 1) << 5 + _1111) << 3
	//	i38      = ((1 + i22) << 4 + _111) << 9 + _111
	//	i50      = 2*((i38 << 4 + _11) << 5 + _1111)
	//	i61      = ((1 + i50) << 5 + _111) << 3 + _11
	//	i75      = ((i61 << 6 + _111) << 4 + _111) << 2
	//	return     ((1 + i75) << 2 + 1) << 3
	//
	// Operations: 64 squares 18 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	z := e.Square(x)
	t0 := e.Mul(x, z)
	t1 := e.Square(t0)
	z = e.Mul(x, t1)
	t2 := e.Square(t1)
	t1 = e.Mul(t0, t2)
	t2 = e.nSquareGS(t2, 3)
	t2 = e.Mul(z, t2)
	t2 = e.nSquareGS(t2, 2)
	t2 = e.Mul(x, t2)
	t2 = e.nSquareGS(t2, 5)
	t2 = e.Mul(t1, t2)
	t2 = e.nSquareGS(t2, 3)
	t2 = e.Mul(x, t2)
	t2 = e.nSquareGS(t2, 4)
	t2 = e.Mul(z, t2)
	t2 = e.nSquareGS(t2, 9)
	t2 = e.Mul(z, t2)
	t2 = e.nSquareGS(t2, 4)
	t2 = e.Mul(t0, t2)
	t2 = e.nSquareGS(t2, 5)
	t1 = e.Mul(t1, t2)
	t1 = e.Square(t1)
	t1 = e.Mul(x, t1)
	t1 = e.nSquareGS(t1, 5)
	t1 = e.Mul(z, t1)
	t1 = e.nSquareGS(t1, 3)
	t0 = e.Mul(t0, t1)
	t0 = e.nSquareGS(t0, 6)
	t0 = e.Mul(z, t0)
	t0 = e.nSquareGS(t0, 4)
	z = e.Mul(z, t0)
	z = e.nSquareGS(z, 2)
	z = e.Mul(x, z)
	z = e.nSquareGS(z, 2)
	z = e.Mul(x, z)
	z = e.nSquareGS(z, 3)

	return z
}

// MulBy01379 multiplies a by an E12 sparse element b of the form
//
//	b.A0  =  1
//	b.A1  =  c3.A0 - 9 * c3.A1
//	b.A2  =  0
//	b.A3  =  c4.A0 - 9 * c4.A1
//	b.A4  =  0
//	b.A5  =  0
//	b.A6  =  0
//	b.A7  =  c3.A1
//	b.A8  =  0
//	b.A9  =  c4.A1
//	b.A10 =  0
//	b.A11 =  0
func (e *Ext12) MulBy01379(a *E12, c3, c4 *E2) *E12 {
	nine := big.NewInt(9)
	b1 := e.fp.Sub(&c3.A0, e.fp.MulConst(&c3.A1, nine))
	b3 := e.fp.Sub(&c4.A0, e.fp.MulConst(&c4.A1, nine))
	b7 := &c3.A1
	b9 := &c4.A1
	// d0  =  a0  - 82 * (a3 b9 + a5 b7 + a9 b3 + a11 b1) - 1476 * (a9 b9 + a11 b7)
	mone := e.fp.NewElement(-1)
	d0 := e.fp.Eval([][]*baseEl{{&a.A0}, {mone, &a.A3, b9}, {mone, &a.A5, b7}, {mone, &a.A9, b3}, {mone, &a.A11, b1}, {mone, &a.A9, b9}, {mone, &a.A11, b7}}, []int{1, 82, 82, 82, 82, 1476, 1476})

	// d1  =  a0 b1 + a1  - 82 * (a4 b9 + a10 b3 + a6 b7) - 1476 * a10 b9
	d1 := e.fp.Eval([][]*baseEl{{&a.A0, b1}, {&a.A1}, {mone, &a.A4, b9}, {mone, &a.A10, b3}, {mone, &a.A6, b7}, {mone, &a.A10, b9}}, []int{1, 1, 82, 82, 82, 1476})

	// d2  =  a1 b1 + a2  - 82 * (a5 b9 + a11 b3 + a7 b7) - 1476 * a11 b9
	d2 := e.fp.Eval([][]*baseEl{{&a.A1, b1}, {&a.A2}, {mone, &a.A5, b9}, {mone, &a.A11, b3}, {mone, &a.A7, b7}, {mone, &a.A11, b9}}, []int{1, 1, 82, 82, 82, 1476})

	// d3  =  a0 b3 + a2 b1 + a3 - 82 * (a6 b9 + a8 b7)
	d3 := e.fp.Eval([][]*baseEl{{&a.A0, b3}, {&a.A2, b1}, {&a.A3}, {mone, &a.A6, b9}, {mone, &a.A8, b7}}, []int{1, 1, 1, 82, 82})

	// d4  =  a1 b3 + a3 b1 + a4  - 82 * (a7 b9 + a9 b7)
	d4 := e.fp.Eval([][]*baseEl{{&a.A1, b3}, {&a.A3, b1}, {&a.A4}, {mone, &a.A7, b9}, {mone, &a.A9, b7}}, []int{1, 1, 1, 82, 82})

	// d5  =  a2 b3 + a4 b1 + a5  - 82 * (a8 b9 + a10 b7)
	d5 := e.fp.Eval([][]*baseEl{{&a.A2, b3}, {&a.A4, b1}, {&a.A5}, {mone, &a.A8, b9}, {mone, &a.A10, b7}}, []int{1, 1, 1, 82, 82})

	// d6  =  a3 b3 + a5 b1 + a6 + 18 * (a3 b9 + a9 b3 + a11 b1 + a5 b7) + 242 * (a9 b9 + a11 b7)
	d6 := e.fp.Eval([][]*baseEl{{&a.A3, b3}, {&a.A5, b1}, {&a.A6}, {&a.A3, b9}, {&a.A9, b3}, {&a.A11, b1}, {&a.A5, b7}, {&a.A11, b7}, {&a.A9, b9}}, []int{1, 1, 1, 18, 18, 18, 18, 242, 242})

	// d7  =  a0 b7 + a4 b3 + a6 b1 + a7 + 18 * (a4 b9 + a10 b3 + a6 b7) + 242 * a10 b9
	d7 := e.fp.Eval([][]*baseEl{{&a.A0, b7}, {&a.A4, b3}, {&a.A6, b1}, {&a.A7}, {&a.A4, b9}, {&a.A10, b3}, {&a.A6, b7}, {&a.A10, b9}}, []int{1, 1, 1, 1, 18, 18, 18, 242})

	// d8  =  a1 b7 + a5 b3 + a7 b1 + a8  + 18 * (a5 b9 + a11 b3 + a7 b7) + 242 * a11 b9
	d8 := e.fp.Eval([][]*baseEl{{&a.A1, b7}, {&a.A5, b3}, {&a.A7, b1}, {&a.A8}, {&a.A5, b9}, {&a.A11, b3}, {&a.A7, b7}, {&a.A11, b9}}, []int{1, 1, 1, 1, 18, 18, 18, 242})

	// d9  =  a2 b7 + a0 b9 + a6 b3 + a8 b1 + a9  + 18 * (a6 b9 + a8 b7)
	d9 := e.fp.Eval([][]*baseEl{{&a.A2, b7}, {&a.A0, b9}, {&a.A6, b3}, {&a.A8, b1}, {&a.A9}, {&a.A6, b9}, {&a.A8, b7}}, []int{1, 1, 1, 1, 1, 18, 18})

	// d10 =  a3 b7 + a1 b9 + a7 b3 + a9 b1 + a10 + 18 * (a7 b9 + a9 b7)
	d10 := e.fp.Eval([][]*baseEl{{&a.A3, b7}, {&a.A1, b9}, {&a.A7, b3}, {&a.A9, b1}, {&a.A10}, {&a.A7, b9}, {&a.A9, b7}}, []int{1, 1, 1, 1, 1, 18, 18})

	// d11 =  a4 b7 + a2 b9 + a8 b3 + a10 b1 + a11 + 18 * (a8 b9 + a10 b7)
	d11 := e.fp.Eval([][]*baseEl{{&a.A4, b7}, {&a.A2, b9}, {&a.A8, b3}, {&a.A10, b1}, {&a.A11}, {&a.A8, b9}, {&a.A10, b7}}, []int{1, 1, 1, 1, 1, 18, 18})

	return &E12{
		A0:  *d0,
		A1:  *d1,
		A2:  *d2,
		A3:  *d3,
		A4:  *d4,
		A5:  *d5,
		A6:  *d6,
		A7:  *d7,
		A8:  *d8,
		A9:  *d9,
		A10: *d10,
		A11: *d11,
	}
}

// AssertFinalExponentiationIsOne checks that a Miller function output x lies in the
// same equivalence class as the reduced pairing. This replaces the final
// exponentiation step in-circuit.
// The method follows Section 4 of [On Proving Pairings] paper by A. Novakovic and L. Eagen.
//
// [On Proving Pairings]: https://eprint.iacr.org/2024/640.pdf
func (e Ext12) AssertFinalExponentiationIsOne(a *E12) {
	nine := big.NewInt(9)
	a000 := e.fp.Add(&a.A0, e.fp.MulConst(&a.A6, nine))
	a001 := &a.A6
	a010 := e.fp.Add(&a.A2, e.fp.MulConst(&a.A8, nine))
	a011 := &a.A8
	a020 := e.fp.Add(&a.A4, e.fp.MulConst(&a.A10, nine))
	a021 := &a.A10
	a100 := e.fp.Add(&a.A1, e.fp.MulConst(&a.A7, nine))
	a101 := &a.A7
	a110 := e.fp.Add(&a.A3, e.fp.MulConst(&a.A9, nine))
	a111 := &a.A9
	a120 := e.fp.Add(&a.A5, e.fp.MulConst(&a.A11, nine))
	a121 := &a.A11

	res, err := e.fp.NewHint(finalExpHint, 24, a000, a001, a010, a011, a020, a021, a100, a101, a110, a111, a120, a121)
	if err != nil {
		// err is non-nil only for invalid number of inputs
		panic(err)
	}

	residueWitness := E12{
		A0:  *e.fp.Sub(res[0], e.fp.MulConst(res[1], nine)),
		A1:  *e.fp.Sub(res[6], e.fp.MulConst(res[7], nine)),
		A2:  *e.fp.Sub(res[2], e.fp.MulConst(res[3], nine)),
		A3:  *e.fp.Sub(res[8], e.fp.MulConst(res[9], nine)),
		A4:  *e.fp.Sub(res[4], e.fp.MulConst(res[5], nine)),
		A5:  *e.fp.Sub(res[10], e.fp.MulConst(res[11], nine)),
		A6:  *res[1],
		A7:  *res[7],
		A8:  *res[3],
		A9:  *res[9],
		A10: *res[5],
		A11: *res[11],
	}

	// constrain cubicNonResiduePower to be in Fp6
	// that is: a100=a101=a110=a111=a120=a121=0
	// or
	//     A0  =  a000 - 9 * a001
	//     A1  =  0
	//     A2  =  a010 - 9 * a011
	//     A3  =  0
	//     A4  =  a020 - 9 * a021
	//     A5  =  0
	//     A6  =  a001
	//     A7  =  0
	//     A8  =  a011
	//     A9  =  0
	//     A10 =  a021
	//     A11 =  0
	cubicNonResiduePower := E12{
		A0:  *e.fp.Sub(res[12], e.fp.MulConst(res[13], nine)),
		A1:  *e.fp.Zero(),
		A2:  *e.fp.Sub(res[14], e.fp.MulConst(res[15], nine)),
		A3:  *e.fp.Zero(),
		A4:  *e.fp.Sub(res[16], e.fp.MulConst(res[17], nine)),
		A5:  *e.fp.Zero(),
		A6:  *res[13],
		A7:  *e.fp.Zero(),
		A8:  *res[15],
		A9:  *e.fp.Zero(),
		A10: *res[17],
		A11: *e.fp.Zero(),
	}

	// Check that  x * cubicNonResiduePower == residueWitness^λ
	// where λ = 6u + 2 + q^3 - q^2 + q, with u the BN254 seed
	// and residueWitness, cubicNonResiduePower from the hint.
	t2 := e.Mul(&cubicNonResiduePower, a)

	t1 := e.FrobeniusCube(&residueWitness)
	t0 := e.FrobeniusSquare(&residueWitness)
	t1 = e.DivUnchecked(t1, t0)
	t0 = e.Frobenius(&residueWitness)
	t1 = e.Mul(t1, t0)

	// exponentiation by U=6u+2
	t0 = e.ExpByU(&residueWitness)

	t0 = e.Mul(t0, t1)

	e.AssertIsEqual(t0, t2)
}
