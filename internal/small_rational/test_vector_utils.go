// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package small_rational

import (
	"fmt"

	"hash"
	"reflect"
)

func ToElement(i int64) *SmallRational {
	var res SmallRational
	res.SetInt64(i)
	return &res
}

type HashDescription map[string]interface{}

func HashFromDescription(d HashDescription) (hash.Hash, error) {
	if _type, ok := d["type"]; ok {
		switch _type {
		case "const":
			startState := int64(d["val"].(float64))
			return &MessageCounter{startState: startState, step: 0, state: startState}, nil
		default:
			return nil, fmt.Errorf("unknown fake hash type \"%s\"", _type)
		}
	}
	return nil, fmt.Errorf("hash description missing type")
}

type MessageCounter struct {
	startState int64
	state      int64
	step       int64
}

func (m *MessageCounter) Write(p []byte) (n int, err error) {
	inputBlockSize := (len(p)-1)/Bytes + 1
	m.state += int64(inputBlockSize) * m.step
	return len(p), nil
}

func (m *MessageCounter) Sum(b []byte) []byte {
	inputBlockSize := (len(b)-1)/Bytes + 1
	resI := m.state + int64(inputBlockSize)*m.step
	var res SmallRational
	res.SetInt64(int64(resI))
	resBytes := res.Bytes()
	return resBytes[:]
}

func (m *MessageCounter) Reset() {
	m.state = m.startState
}

func (m *MessageCounter) Size() int {
	return Bytes
}

func (m *MessageCounter) BlockSize() int {
	return Bytes
}

func NewMessageCounter(startState, step int) hash.Hash {
	transcript := &MessageCounter{startState: int64(startState), state: int64(startState), step: int64(step)}
	return transcript
}

type ListHash []SmallRational

func (h *ListHash) Write(p []byte) (n int, err error) {
	return len(p), nil
}

func (h *ListHash) Sum(b []byte) []byte {
	res := (*h)[0].Bytes()
	*h = (*h)[1:]
	return res[:]
}

func (h *ListHash) Reset() {
}

func (h *ListHash) Size() int {
	return Bytes
}

func (h *ListHash) BlockSize() int {
	return Bytes
}

func SliceToElementSlice[T any](slice []T) ([]SmallRational, error) {
	elementSlice := make([]SmallRational, len(slice))
	for i, v := range slice {
		if _, err := elementSlice[i].SetInterface(v); err != nil {
			return nil, err
		}
	}
	return elementSlice, nil
}

func ElementToInterface(x *SmallRational) interface{} {
	if i := x.BigInt(nil); i != nil {
		return i
	}
	return x.Text(10)
}

func ElementSliceToInterfaceSlice(x interface{}) []interface{} {
	if x == nil {
		return nil
	}

	X := reflect.ValueOf(x)

	res := make([]interface{}, X.Len())
	for i := range res {
		xI := X.Index(i).Interface().(SmallRational)
		res[i] = ElementToInterface(&xI)
	}
	return res
}

func ElementSliceSliceToInterfaceSliceSlice(x interface{}) [][]interface{} {
	if x == nil {
		return nil
	}

	X := reflect.ValueOf(x)

	res := make([][]interface{}, X.Len())
	for i := range res {
		res[i] = ElementSliceToInterfaceSlice(X.Index(i).Interface())
	}

	return res
}
