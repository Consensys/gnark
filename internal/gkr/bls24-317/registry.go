// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package gkr

import (
	"fmt"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/ecc/bls24-317/fr"
	"github.com/consensys/gnark-crypto/ecc/bls24-317/fr/fft"
	"github.com/consensys/gnark-crypto/ecc/bls24-317/fr/polynomial"
	"github.com/consensys/gnark/internal/gkr"
	"slices"
	"sync"
)

type GateName string

var (
	gates     = make(map[GateName]*Gate)
	gatesLock sync.Mutex
)

// isAdditive returns whether x_i occurs only in a monomial of total degree 1 in f
func (f GateFunction) isAdditive(i, nbIn int) bool {
	// fix all variables except the i-th one at random points
	// pick random value x1 for the i-th variable
	// check if f(-, 0, -) + f(-, 2*x1, -) = 2*f(-, x1, -)
	x := make(fr.Vector, nbIn)
	x.MustSetRandom()
	x0 := x[i]
	x[i].SetZero()
	in := slices.Clone(x)
	y0 := f(in...)

	x[i] = x0
	copy(in, x)
	y1 := f(in...)

	x[i].Double(&x[i])
	copy(in, x)
	y2 := f(in...)

	y2.Sub(&y2, &y1)
	y1.Sub(&y1, &y0)

	if !y2.Equal(&y1) {
		return false // not linear
	}

	// check if the coefficient of x_i is nonzero and independent of the other variables (so that we know it is ALWAYS nonzero)
	if y1.IsZero() { // f(-, x1, -) = f(-, 0, -), so the coefficient of x_i is 0
		return false
	}

	// compute the slope with another assignment for the other variables
	x.MustSetRandom()
	x[i].SetZero()
	copy(in, x)
	y0 = f(in...)

	x[i] = x0
	copy(in, x)
	y1 = f(in...)

	y1.Sub(&y1, &y0)

	return y1.Equal(&y2)
}

// fitPoly tries to fit a polynomial of degree less than degreeBound to f.
// degreeBound must be a power of 2.
// It returns the polynomial if successful, nil otherwise
func (f GateFunction) fitPoly(nbIn int, degreeBound uint64) polynomial.Polynomial {
	// turn f univariate by defining p(x) as f(x, rx, ..., sx)
	// where r, s, ... are random constants
	fIn := make([]fr.Element, nbIn)
	consts := make(fr.Vector, nbIn-1)
	consts.MustSetRandom()

	p := make(polynomial.Polynomial, degreeBound)
	domain := fft.NewDomain(degreeBound)
	// evaluate p on the unit circle (first filling p with evaluations rather than coefficients)
	x := fr.One()
	for i := range p {
		fIn[0] = x
		for j := range consts {
			fIn[j+1].Mul(&x, &consts[j])
		}
		p[i] = f(fIn...)

		x.Mul(&x, &domain.Generator)
	}

	// obtain p's coefficients
	domain.FFTInverse(p, fft.DIF)
	fft.BitReverse(p)

	// check if p is equal to f. This not being the case means that f is of a degree higher than degreeBound
	fIn[0].MustSetRandom()
	for i := range consts {
		fIn[i+1].Mul(&fIn[0], &consts[i])
	}
	pAt := p.Eval(&fIn[0])
	fAt := f(fIn...)
	if !pAt.Equal(&fAt) {
		return nil
	}

	// trim p
	lastNonZero := len(p) - 1
	for lastNonZero >= 0 && p[lastNonZero].IsZero() {
		lastNonZero--
	}
	return p[:lastNonZero+1]
}

type errorString string

func (e errorString) Error() string {
	return string(e)
}

const errZeroFunction = errorString("detected a zero function")

// FindDegree returns the degree of the gate function, or -1 if it fails.
// Failure could be due to the degree being higher than max or the function not being a polynomial at all.
func (f GateFunction) FindDegree(max, nbIn int) (int, error) {
	bound := uint64(max) + 1
	for degreeBound := uint64(4); degreeBound <= bound; degreeBound *= 8 {
		if p := f.fitPoly(nbIn, degreeBound); p != nil {
			if len(p) == 0 {
				return -1, errZeroFunction
			}
			return len(p) - 1, nil
		}
	}
	return -1, fmt.Errorf("could not find a degree: tried up to %d", max)
}

func (f GateFunction) VerifyDegree(claimedDegree, nbIn int) error {
	if p := f.fitPoly(nbIn, ecc.NextPowerOfTwo(uint64(claimedDegree)+1)); p == nil {
		return fmt.Errorf("detected a higher degree than %d", claimedDegree)
	} else if len(p) == 0 {
		return errZeroFunction
	} else if len(p)-1 != claimedDegree {
		return fmt.Errorf("detected degree %d, claimed %d", len(p)-1, claimedDegree)
	}
	return nil
}

// FindSolvableVar returns the index of a variable whose value can be uniquely determined from that of the other variables along with the gate's output.
// It returns -1 if it fails to find one.
// nbIn is the number of inputs to the gate
func (f GateFunction) FindSolvableVar(nbIn int) int {
	for i := range nbIn {
		if f.isAdditive(i, nbIn) {
			return i
		}
	}
	return -1
}

// IsVarSolvable returns whether claimedSolvableVar is a variable whose value can be uniquely determined from that of the other variables along with the gate's output.
// It returns false if it fails to verify this claim.
// nbIn is the number of inputs to the gate.
func (f GateFunction) IsVarSolvable(claimedSolvableVar, nbIn int) bool {
	return f.isAdditive(claimedSolvableVar, nbIn)
}

// RegisterGate creates a gate object and stores it in the gates registry.
// name is a human-readable name for the gate.
// f is the polynomial function defining the gate.
// nbIn is the number of inputs to the gate.
func RegisterGate(name GateName, f GateFunction, nbIn int, settings gkr.RegisterGateSettings) error {

	if settings.Degree == -1 { // find a degree
		if settings.NoDegreeVerification {
			panic("invalid settings")
		}
		const maxAutoDegreeBound = 32
		var err error
		if settings.Degree, err = f.FindDegree(maxAutoDegreeBound, nbIn); err != nil {
			return fmt.Errorf("for gate %s: %v", name, err)
		}
	} else {
		if !settings.NoDegreeVerification { // check that the given degree is correct
			if err := f.VerifyDegree(settings.Degree, nbIn); err != nil {
				return fmt.Errorf("for gate %s: %v", name, err)
			}
		}
	}

	if settings.SolvableVar == -1 {
		if !settings.NoSolvableVarVerification { // find a solvable variable
			settings.SolvableVar = f.FindSolvableVar(nbIn)
		}
	} else {
		// solvable variable given
		if !settings.NoSolvableVarVerification && !f.IsVarSolvable(settings.SolvableVar, nbIn) {
			return fmt.Errorf("cannot verify the solvability of variable %d in gate %s", settings.SolvableVar, name)
		}
	}

	gatesLock.Lock()
	defer gatesLock.Unlock()
	gates[name] = &Gate{Evaluate: f, nbIn: nbIn, degree: settings.Degree, solvableVar: settings.SolvableVar}
	return nil
}

func GetGate(name GateName) *Gate {
	gatesLock.Lock()
	defer gatesLock.Unlock()
	return gates[name]
}

const (
	Identity GateName = "identity" // Identity gate: x -> x
	Add2     GateName = "add2"     // Add2 gate: (x, y) -> x + y
	Sub2     GateName = "sub2"     // Sub2 gate: (x, y) -> x - y
	Neg      GateName = "neg"      // Neg gate: x -> -x
	Mul2     GateName = "mul2"     // Mul2 gate: (x, y) -> x * y
)

func init() {
	// register some basic gates

	if err := RegisterGate(Identity, func(x ...fr.Element) fr.Element {
		return x[0]
	}, 1, gkr.NewRegisterGateSettings(gkr.WithUnverifiedDegree(1), gkr.WithUnverifiedSolvableVar(0))); err != nil {
		panic(err)
	}

	if err := RegisterGate(Add2, func(x ...fr.Element) fr.Element {
		var res fr.Element
		res.Add(&x[0], &x[1])
		return res
	}, 2, gkr.NewRegisterGateSettings(gkr.WithUnverifiedDegree(1), gkr.WithUnverifiedSolvableVar(0))); err != nil {
		panic(err)
	}

	if err := RegisterGate(Sub2, func(x ...fr.Element) fr.Element {
		var res fr.Element
		res.Sub(&x[0], &x[1])
		return res
	}, 2, gkr.NewRegisterGateSettings(gkr.WithUnverifiedDegree(1), gkr.WithUnverifiedSolvableVar(0))); err != nil {
		panic(err)
	}

	if err := RegisterGate(Neg, func(x ...fr.Element) fr.Element {
		var res fr.Element
		res.Neg(&x[0])
		return res
	}, 1, gkr.NewRegisterGateSettings(gkr.WithUnverifiedDegree(1), gkr.WithUnverifiedSolvableVar(0))); err != nil {
		panic(err)
	}

	if err := RegisterGate(Mul2, func(x ...fr.Element) fr.Element {
		var res fr.Element
		res.Mul(&x[0], &x[1])
		return res
	}, 2, gkr.NewRegisterGateSettings(gkr.WithUnverifiedDegree(2), gkr.WithNoSolvableVar())); err != nil {
		panic(err)
	}
}
