// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package gkr

import (
	"fmt"
	"math/big"

	"github.com/consensys/gnark-crypto/hash"
	hint "github.com/consensys/gnark/constraint/solver"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/internal/gkr/gkrinfo"
	"github.com/consensys/gnark/internal/gkr/gkrtypes"
	algo_utils "github.com/consensys/gnark/internal/utils"

	"github.com/consensys/gnark-crypto/ecc/bw6-761/fr"
	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
)

type SolvingData struct {
	assignment       WireAssignment
	circuit          gkrtypes.Circuit
	maxNbIn          int // maximum number of inputs for a gate in the circuit
	printsByInstance map[uint32][]gkrinfo.PrintInfo
}

type newSolvingDataSettings struct {
	assignment gkrtypes.WireAssignment
}

type newSolvingDataOption func(*newSolvingDataSettings)

func WithAssignment(assignment gkrtypes.WireAssignment) newSolvingDataOption {
	return func(s *newSolvingDataSettings) {
		s.assignment = assignment
	}
}

func NewSolvingData(info gkrtypes.SolvingInfo, options ...newSolvingDataOption) *SolvingData {
	var s newSolvingDataSettings
	for _, opt := range options {
		opt(&s)
	}

	d := SolvingData{
		circuit:          info.Circuit,
		assignment:       make(WireAssignment, len(info.Circuit)),
		printsByInstance: gkrinfo.NewPrintInfoMap(info.Prints),
	}

	d.maxNbIn = d.circuit.MaxGateNbIn()

	d.assignment = make(WireAssignment, len(d.circuit))
	for i := range d.assignment {
		d.assignment[i] = make([]fr.Element, info.NbInstances)
	}

	if s.assignment != nil {
		if len(s.assignment) != len(d.assignment) {
			panic(fmt.Errorf("provided assignment has %d wires, expected %d", len(s.assignment), len(d.assignment)))
		}
		for i := range d.assignment {
			if len(s.assignment[i]) != info.NbInstances {
				panic(fmt.Errorf("provided assignment for wire %d has %d instances, expected %d", i, len(s.assignment[i]), info.NbInstances))
			}
			for j := range d.assignment[i] {
				if _, err := d.assignment[i][j].SetInterface(s.assignment[i][j]); err != nil {
					panic(fmt.Errorf("provided assignment for wire %d instance %d is not a valid field element: %w", i, j, err))
				}
			}
		}
	}

	return &d
}

// this module assumes that wire and instance indexes respect dependencies

func SolveHint(data *SolvingData) hint.Hint {
	return func(_ *big.Int, ins, outs []*big.Int) error {
		instanceI := ins[0].Uint64()
		if !ins[0].IsUint64() {
			return fmt.Errorf("first input to solving hint must be the instance index; provided value %s doesn't fit in 64 bits", ins[0])
		}

		gateIns := make([]frontend.Variable, data.maxNbIn)
		outsI := 0
		insI := 1 // skip the first input, which is the instance index
		for wI := range data.circuit {
			w := &data.circuit[wI]
			if w.IsInput() { // read from provided input
				data.assignment[wI][instanceI].SetBigInt(ins[insI])
				insI++
			} else {

				// assemble input for gate
				for i, inWI := range w.Inputs {
					gateIns[i] = &data.assignment[inWI][instanceI]
				}

				data.assignment[wI][instanceI].Set(w.Gate.Evaluate(api, gateIns[:len(w.Inputs)]...).(*fr.Element))
			}
			if w.IsOutput() {
				data.assignment[wI][instanceI].BigInt(outs[outsI])
				outsI++
			}
		}

		prints := data.printsByInstance[uint32(instanceI)]
		delete(data.printsByInstance, uint32(instanceI))
		for _, p := range prints {
			serializable := make([]any, len(p.Values))
			for i, v := range p.Values {
				if p.IsGkrVar[i] { // serializer stores uint32 in slices as uint64
					serializable[i] = data.assignment[algo_utils.ForceUint32(v)][p.Instance].String()
				} else {
					serializable[i] = v
				}
			}
			fmt.Println(serializable...)
		}
		return nil
	}
}

func ProveHint(hashName string, data *SolvingData) hint.Hint {

	return func(_ *big.Int, ins, outs []*big.Int) error {
		insBytes := algo_utils.Map(ins[1:], func(i *big.Int) []byte { // the first input is dummy, just to ensure the solver's work is done before the prover is called
			b := make([]byte, fr.Bytes)
			i.FillBytes(b)
			return b[:]
		})

		hsh := hash.NewHash(hashName + "_BW6_761")

		proof, err := Prove(data.circuit, data.assignment, fiatshamir.WithHash(hsh, insBytes...))
		if err != nil {
			return err
		}

		return proof.SerializeToBigInts(outs)

	}
}
