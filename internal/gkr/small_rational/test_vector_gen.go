// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package gkr

import (
	"encoding/json"
	"fmt"
	"hash"
	"os"
	"path/filepath"
	"reflect"

	"github.com/consensys/bavard"
	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark/internal/small_rational"
	"github.com/consensys/gnark/internal/small_rational/polynomial"
)

func GenerateVectors() error {
	testDirPath, err := filepath.Abs("../../gkr/test_vectors")
	if err != nil {
		return err
	}

	fmt.Printf("generating GKR test cases: scanning directory %s for test specs\n", testDirPath)

	dirEntries, err := os.ReadDir(testDirPath)
	if err != nil {
		return err
	}
	for _, dirEntry := range dirEntries {
		if !dirEntry.IsDir() {

			if filepath.Ext(dirEntry.Name()) == ".json" {
				path := filepath.Join(testDirPath, dirEntry.Name())
				if !bavard.ShouldGenerate(path) {
					continue
				}
				fmt.Println("\tprocessing", dirEntry.Name())
				if err = run(path); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

func run(absPath string) error {
	testCase, err := newTestCase(absPath)
	if err != nil {
		return err
	}

	transcriptSetting := fiatshamir.WithHash(testCase.Hash)

	var proof Proof
	proof, err = Prove(testCase.Circuit, testCase.FullAssignment, transcriptSetting)
	if err != nil {
		return err
	}

	if testCase.Info.Proof, err = toPrintableProof(proof); err != nil {
		return err
	}
	var outBytes []byte
	if outBytes, err = json.MarshalIndent(testCase.Info, "", "\t"); err == nil {
		if err = os.WriteFile(absPath, outBytes, 0); err != nil {
			return err
		}
	} else {
		return err
	}

	testCase, err = newTestCase(absPath)
	if err != nil {
		return err
	}

	err = Verify(testCase.Circuit, testCase.InOutAssignment, proof, transcriptSetting)
	if err != nil {
		return err
	}

	testCase, err = newTestCase(absPath)
	if err != nil {
		return err
	}

	err = Verify(testCase.Circuit, testCase.InOutAssignment, proof, fiatshamir.WithHash(newMessageCounter(2, 0)))
	if err == nil {
		return fmt.Errorf("bad proof accepted")
	}
	return nil
}

func toPrintableProof(proof Proof) (PrintableProof, error) {
	res := make(PrintableProof, len(proof))

	for i := range proof {

		partialSumPolys := make([][]interface{}, len(proof[i].partialSumPolys))
		for k, partialK := range proof[i].partialSumPolys {
			partialSumPolys[k] = elementSliceToInterfaceSlice(partialK)
		}

		res[i] = PrintableSumcheckProof{
			FinalEvalProof:  elementSliceToInterfaceSlice(proof[i].finalEvalProof),
			PartialSumPolys: partialSumPolys,
		}
	}
	return res, nil
}

type WireInfo struct {
	Gate   GateName `json:"gate"`
	Inputs []int    `json:"inputs"`
}

type CircuitInfo []WireInfo

var circuitCache = make(map[string]Circuit)

func getCircuit(path string) (Circuit, error) {
	path, err := filepath.Abs(path)
	if err != nil {
		return nil, err
	}
	if circuit, ok := circuitCache[path]; ok {
		return circuit, nil
	}
	var bytes []byte
	if bytes, err = os.ReadFile(path); err == nil {
		var circuitInfo CircuitInfo
		if err = json.Unmarshal(bytes, &circuitInfo); err == nil {
			circuit := circuitInfo.toCircuit()
			circuitCache[path] = circuit
			return circuit, nil
		} else {
			return nil, err
		}
	} else {
		return nil, err
	}
}

func (c CircuitInfo) toCircuit() (circuit Circuit) {
	circuit = make(Circuit, len(c))
	for i := range c {
		circuit[i].Gate = GetGate(c[i].Gate)
		circuit[i].Inputs = make([]*Wire, len(c[i].Inputs))
		for k, inputCoord := range c[i].Inputs {
			input := &circuit[inputCoord]
			circuit[i].Inputs[k] = input
		}
	}
	return
}

func mimcRound(input ...small_rational.SmallRational) (res small_rational.SmallRational) {
	var sum small_rational.SmallRational

	sum.
		Add(&input[0], &input[1]) //.Add(&sum, &m.ark)  TODO: add ark
	res.Square(&sum)    // sum^2
	res.Mul(&res, &sum) // sum^3
	res.Square(&res)    //sum^6
	res.Mul(&res, &sum) //sum^7

	return
}

const (
	MiMC         GateName = "mimc"
	SelectInput3 GateName = "select-input-3"
)

func init() {
	if err := RegisterGate(MiMC, mimcRound, 2, WithUnverifiedDegree(7)); err != nil {
		panic(err)
	}

	if err := RegisterGate(SelectInput3, func(input ...small_rational.SmallRational) small_rational.SmallRational {
		return input[2]
	}, 3, WithUnverifiedDegree(1)); err != nil {
		panic(err)
	}
}

type PrintableProof []PrintableSumcheckProof

type PrintableSumcheckProof struct {
	FinalEvalProof  interface{}     `json:"finalEvalProof"`
	PartialSumPolys [][]interface{} `json:"partialSumPolys"`
}

func unmarshalProof(printable PrintableProof) (Proof, error) {
	proof := make(Proof, len(printable))
	for i := range printable {
		finalEvalProof := []small_rational.SmallRational(nil)

		if printable[i].FinalEvalProof != nil {
			finalEvalSlice := reflect.ValueOf(printable[i].FinalEvalProof)
			finalEvalProof = make([]small_rational.SmallRational, finalEvalSlice.Len())
			for k := range finalEvalProof {
				if _, err := finalEvalProof[k].SetInterface(finalEvalSlice.Index(k).Interface()); err != nil {
					return nil, err
				}
			}
		}

		proof[i] = sumcheckProof{
			partialSumPolys: make([]polynomial.Polynomial, len(printable[i].PartialSumPolys)),
			finalEvalProof:  finalEvalProof,
		}
		for k := range printable[i].PartialSumPolys {
			var err error
			if proof[i].partialSumPolys[k], err = sliceToElementSlice(printable[i].PartialSumPolys[k]); err != nil {
				return nil, err
			}
		}
	}
	return proof, nil
}

type TestCase struct {
	Circuit         Circuit
	Hash            hash.Hash
	Proof           Proof
	FullAssignment  WireAssignment
	InOutAssignment WireAssignment
	Info            TestCaseInfo // we are generating the test vectors, so we need to keep the circuit instance info to ADD the proof to it and resave it
}

type TestCaseInfo struct {
	Hash    hashDescription `json:"hash"`
	Circuit string          `json:"circuit"`
	Input   [][]interface{} `json:"input"`
	Output  [][]interface{} `json:"output"`
	Proof   PrintableProof  `json:"proof"`
}

var testCases = make(map[string]*TestCase)

func newTestCase(path string) (*TestCase, error) {
	path, err := filepath.Abs(path)
	if err != nil {
		return nil, err
	}
	dir := filepath.Dir(path)

	tCase, ok := testCases[path]
	if !ok {
		var bytes []byte
		if bytes, err = os.ReadFile(path); err == nil {
			var info TestCaseInfo
			err = json.Unmarshal(bytes, &info)
			if err != nil {
				return nil, err
			}

			var circuit Circuit
			if circuit, err = getCircuit(filepath.Join(dir, info.Circuit)); err != nil {
				return nil, err
			}
			var _hash hash.Hash
			if _hash, err = hashFromDescription(info.Hash); err != nil {
				return nil, err
			}
			var proof Proof
			if proof, err = unmarshalProof(info.Proof); err != nil {
				return nil, err
			}

			fullAssignment := make(WireAssignment)
			inOutAssignment := make(WireAssignment)

			sorted := topologicalSort(circuit)

			inI, outI := 0, 0
			for _, w := range sorted {
				var assignmentRaw []interface{}
				if w.IsInput() {
					if inI == len(info.Input) {
						return nil, fmt.Errorf("fewer input in vector than in circuit")
					}
					assignmentRaw = info.Input[inI]
					inI++
				} else if w.IsOutput() {
					if outI == len(info.Output) {
						return nil, fmt.Errorf("fewer output in vector than in circuit")
					}
					assignmentRaw = info.Output[outI]
					outI++
				}
				if assignmentRaw != nil {
					var wireAssignment []small_rational.SmallRational
					if wireAssignment, err = sliceToElementSlice(assignmentRaw); err != nil {
						return nil, err
					}

					fullAssignment[w] = wireAssignment
					inOutAssignment[w] = wireAssignment
				}
			}

			fullAssignment.Complete(circuit)

			for _, w := range sorted {
				if w.IsOutput() {

					if err = sliceEquals(inOutAssignment[w], fullAssignment[w]); err != nil {
						return nil, fmt.Errorf("assignment mismatch: %v", err)
					}

				}
			}

			tCase = &TestCase{
				FullAssignment:  fullAssignment,
				InOutAssignment: inOutAssignment,
				Proof:           proof,
				Hash:            _hash,
				Circuit:         circuit,
				Info:            info,
			}

			testCases[path] = tCase
		} else {
			return nil, err
		}
	}

	return tCase, nil
}
