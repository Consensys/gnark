// Copyright 2020-2026 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package gkr

import (
	"fmt"
	"math/big"
	"math/bits"
	"sync"

	"github.com/consensys/gnark-crypto/ecc/bls12-381/fr"
	"github.com/consensys/gnark-crypto/ecc/bls12-381/fr/polynomial"
	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark-crypto/hash"
	"github.com/consensys/gnark/constraint"
	gadget "github.com/consensys/gnark/internal/gkr"
	"github.com/consensys/gnark/internal/gkr/gkrtypes"
)

// circuitEvaluator evaluates all gates in a circuit for one instance
type circuitEvaluator struct {
	evaluators []gateEvaluator // one evaluator per wire
}

// BlueprintSolve is a BLS12_381-specific blueprint for solving GKR circuit instances.
type BlueprintSolve struct {
	// Circuit structure (serialized)
	Circuit     gkrtypes.SerializableCircuit
	NbInstances uint32

	// Not serialized - recreated lazily at solve time
	assignment    WireAssignment `cbor:"-"` // []polynomial.MultiLin
	evaluatorPool sync.Pool      `cbor:"-"` // pool of circuitEvaluator, lazy-initialized
	nbInputs      int            `cbor:"-"`
	inputWires    []int          `cbor:"-"`
	outputWires   []int          `cbor:"-"`
	maxNbIn       int            `cbor:"-"` // maximum number of inputs for any gate

	lock sync.Mutex `cbor:"-"`
}

// Ensures BlueprintSolve implements BlueprintStateful
var _ constraint.BlueprintStateful[constraint.U64] = (*BlueprintSolve)(nil)

func (b *BlueprintSolve) initialize() {

	if b.assignment != nil {
		return
	}
	b.lock.Lock()
	defer b.lock.Unlock()

	if b.assignment != nil {
		return // the unlikely event that two or more instructions were competing to initialize the blueprint
	}

	// Compute metadata from Circuit
	for i := range b.Circuit {
		if b.Circuit[i].IsInput() {
			b.nbInputs++
			b.inputWires = append(b.inputWires, i)
		} else {
			b.maxNbIn = max(b.maxNbIn, len(b.Circuit[i].Inputs))
		}
	}

	b.outputWires = b.Circuit.Outputs()

	b.evaluatorPool.New = func() interface{} {
		ce := &circuitEvaluator{
			evaluators: make([]gateEvaluator, len(b.Circuit)),
		}
		for wI := range b.Circuit {
			w := &b.Circuit[wI]
			if !w.IsInput() {
				ce.evaluators[wI] = newGateEvaluator(w.Gate.Evaluate, len(w.Inputs))
			}
		}
		return ce
	}

	b.assignment = make(WireAssignment, len(b.Circuit))
	for i := range b.assignment {
		b.assignment[i] = make(polynomial.MultiLin, b.NbInstances)
	}
}

// Solve implements the BlueprintStateful interface.
func (b *BlueprintSolve) Solve(s constraint.Solver[constraint.U64], inst constraint.Instruction) error {

	b.initialize()

	// Get a circuit evaluator from the pool
	ce := b.evaluatorPool.Get().(*circuitEvaluator)
	defer b.evaluatorPool.Put(ce)

	instanceI := int(inst.Calldata[0])
	calldata := inst.Calldata[1:]

	// Process all wires in topological order (circuit is already sorted)
	for wI := range b.Circuit {
		w := &b.Circuit[wI]

		if w.IsInput() {
			val, delta := s.Read(calldata)
			calldata = calldata[delta:]
			// Copy directly from constraint.U64 to fr.Element (both in Montgomery form)
			copy(b.assignment[wI][instanceI][:], val[:])
		} else {
			// Get evaluator for this wire from the circuit evaluator
			evaluator := &ce.evaluators[wI]

			// Push gate inputs
			for _, inWI := range w.Inputs {
				evaluator.pushInput(&b.assignment[inWI][instanceI])
			}

			// Evaluate the gate
			b.assignment[wI][instanceI].Set(evaluator.evaluate())
		}
	}

	// Set output wires (copy fr.Element to U64 in Montgomery form)
	for outI, outWI := range b.outputWires {
		var val constraint.U64
		copy(val[:], b.assignment[outWI][instanceI][:])
		s.SetValue(uint32(outI+int(inst.WireOffset)), val)
	}

	return nil
}

// Reset implements BlueprintStateful
func (b *BlueprintSolve) Reset() {
	b.assignment = nil
}

// SetNbInstances sets the number of instances for the blueprint
func (b *BlueprintSolve) SetNbInstances(nbInstances uint32) {
	b.NbInstances = nbInstances
}

// CalldataSize implements Blueprint
func (b *BlueprintSolve) CalldataSize() int {
	return -1 // variable size
}

// NbConstraints implements Blueprint
func (b *BlueprintSolve) NbConstraints() int {
	return 0
}

// NbOutputs implements Blueprint
func (b *BlueprintSolve) NbOutputs(inst constraint.Instruction) int {
	return len(b.Circuit.Outputs())
}

// UpdateInstructionTree implements Blueprint
func (b *BlueprintSolve) UpdateInstructionTree(inst constraint.Instruction, tree constraint.InstructionTree) constraint.Level {
	b.initialize() // circuit metadata

	maxLevel := constraint.LevelUnset

	// Parse exactly b.nbInputs linear expressions
	offset := 1 // skip instance index
	for range b.nbInputs {
		n := int(inst.Calldata[offset])
		offset++

		for range n {
			wireID := inst.Calldata[offset+1]
			offset += 2
			if !tree.HasWire(wireID) {
				continue
			}
			if level := tree.GetWireLevel(wireID); level > maxLevel {
				maxLevel = level
			}
		}
	}

	outputLevel := maxLevel + 1
	for i := range b.outputWires {
		tree.InsertWire(uint32(i+int(inst.WireOffset)), outputLevel)
	}

	return outputLevel
}

// GetAssignment returns the assignment for a specific wire and instance (internal use)
func (b *BlueprintSolve) GetAssignment(wireI, instanceI int) (constraint.U64, error) {
	b.lock.Lock()
	defer b.lock.Unlock()

	var zero constraint.U64
	if wireI >= len(b.assignment) || instanceI >= len(b.assignment[wireI]) {
		return zero, fmt.Errorf("wire %d instance %d out of bounds", wireI, instanceI)
	}

	// Copy fr.Element to U64 directly (both in Montgomery form)
	var val constraint.U64
	copy(val[:], b.assignment[wireI][instanceI][:])
	return val, nil
}

// GetAssignments returns all assignments for proving
func (b *BlueprintSolve) GetAssignments() WireAssignment {
	b.lock.Lock()
	defer b.lock.Unlock()
	return b.assignment
}

// BlueprintProve is a BLS12_381-specific blueprint for generating GKR proofs.
type BlueprintProve struct {
	SolveBlueprintID constraint.BlueprintID
	SolveBlueprint   *BlueprintSolve `cbor:"-"` // not serialized, set at compile time
	HashName         string

	lock sync.Mutex
}

// Ensures BlueprintProve implements BlueprintSolvable
var _ constraint.BlueprintSolvable[constraint.U64] = (*BlueprintProve)(nil)

// Solve implements the BlueprintSolvable interface for proving.
func (b *BlueprintProve) Solve(s constraint.Solver[constraint.U64], inst constraint.Instruction) error {
	b.lock.Lock()
	defer b.lock.Unlock()

	// Get solve blueprint from solver by ID
	solveBlueprint := s.GetBlueprint(b.SolveBlueprintID).(*BlueprintSolve)

	// Get assignments from solve blueprint (already in fr.Element form)
	assignments := solveBlueprint.GetAssignments()
	if len(assignments) == 0 {
		return fmt.Errorf("no assignments available for proving")
	}

	// Read initial challenges from instruction calldata (parse dynamically, no metadata)
	insBytes := make([][]byte, 0) // first challenges
	calldata := inst.Calldata
	for len(calldata) != 0 {
		val, delta := s.Read(calldata)
		calldata = calldata[delta:]

		// Copy directly from constraint.U64 to fr.Element (both in Montgomery form)
		var challenge fr.Element
		copy(challenge[:], val[:])
		insBytes = append(insBytes, challenge.Marshal())
	}

	// Create Fiat-Shamir settings
	hsh := hash.NewHash(b.HashName + "_BLS12_381")
	fsSettings := fiatshamir.WithHash(hsh, insBytes...)

	// Call the BLS12_381-specific Prove function (assignments already WireAssignment type)
	proof, err := Prove(solveBlueprint.Circuit, assignments, fsSettings)
	if err != nil {
		return fmt.Errorf("bls12_381 prove failed: %w", err)
	}

	// Serialize proof and convert to U64
	proofSize := 0
	for i := range proof {
		for _, poly := range proof[i].partialSumPolys {
			proofSize += len(poly)
		}
		if proof[i].finalEvalProof != nil {
			proofSize += len(proof[i].finalEvalProof)
		}
	}

	outsBig := make([]*big.Int, proofSize)
	for i := range outsBig {
		outsBig[i] = new(big.Int)
	}
	if err := proof.SerializeToBigInts(outsBig); err != nil {
		return fmt.Errorf("failed to serialize proof: %w", err)
	}

	// Set output wires (convert big.Int to U64)
	for i, bigVal := range outsBig {
		s.SetValue(uint32(i+int(inst.WireOffset)), s.FromInterface(bigVal))
	}

	return nil
}

// CalldataSize implements Blueprint
func (b *BlueprintProve) CalldataSize() int {
	return -1 // variable size
}

// NbConstraints implements Blueprint
func (b *BlueprintProve) NbConstraints() int {
	return 0
}

func (b *BlueprintProve) proofSize() int {
	if b.SolveBlueprint.NbInstances < 2 {
		return 0
	}
	logNbInstances := bits.TrailingZeros32(b.SolveBlueprint.NbInstances)
	return b.SolveBlueprint.Circuit.ProofSize(logNbInstances)
}

// NbOutputs implements Blueprint
func (b *BlueprintProve) NbOutputs(inst constraint.Instruction) int {
	return b.proofSize()
}

// UpdateInstructionTree implements Blueprint
func (b *BlueprintProve) UpdateInstructionTree(inst constraint.Instruction, tree constraint.InstructionTree) constraint.Level {
	maxLevel := constraint.LevelUnset

	// Parse all challenges dynamically (no metadata)
	offset := 0
	for offset < len(inst.Calldata) {
		n := int(inst.Calldata[offset])
		offset++

		for range n {
			wireID := inst.Calldata[offset+1]
			offset += 2
			if !tree.HasWire(wireID) {
				continue
			}
			if level := tree.GetWireLevel(wireID); level > maxLevel {
				maxLevel = level
			}
		}
	}

	outputLevel := maxLevel + 1
	// Compute proof size from blueprint state
	if b.SolveBlueprint.NbInstances > 0 {
		proofSize := b.proofSize()
		for i := range proofSize {
			tree.InsertWire(uint32(i+int(inst.WireOffset)), outputLevel)
		}
	}

	return outputLevel
}

// BlueprintGetAssignment is a BLS12_381-specific blueprint for retrieving wire assignments.
type BlueprintGetAssignment struct {
	SolveBlueprintID constraint.BlueprintID
	SolveBlueprint   *BlueprintSolve `cbor:"-"` // not serialized, set at compile time

	lock sync.Mutex
}

// Ensures BlueprintGetAssignment implements BlueprintSolvable
var _ constraint.BlueprintSolvable[constraint.U64] = (*BlueprintGetAssignment)(nil)

// Solve implements the BlueprintSolvable interface for getting assignments.
func (b *BlueprintGetAssignment) Solve(s constraint.Solver[constraint.U64], inst constraint.Instruction) error {
	b.lock.Lock()
	defer b.lock.Unlock()

	// Read wireI and instanceI from calldata
	wireI := int(inst.Calldata[0])
	instanceI := int(inst.Calldata[1])

	// Get solve blueprint from solver by ID
	solveBlueprint := s.GetBlueprint(b.SolveBlueprintID).(*BlueprintSolve)

	// Get assignment
	val, err := solveBlueprint.GetAssignment(wireI, instanceI)
	if err != nil {
		return err
	}

	// Set output wire
	s.SetValue(inst.WireOffset, val)
	return nil
}

// CalldataSize implements Blueprint
func (b *BlueprintGetAssignment) CalldataSize() int {
	return -1 // variable size: [wireI, instanceI, dependency_linear_expression]
}

// NbConstraints implements Blueprint
func (b *BlueprintGetAssignment) NbConstraints() int {
	return 0
}

// NbOutputs implements Blueprint
func (b *BlueprintGetAssignment) NbOutputs(inst constraint.Instruction) int {
	return 1 // returns one assignment value
}

// UpdateInstructionTree implements Blueprint
func (b *BlueprintGetAssignment) UpdateInstructionTree(inst constraint.Instruction, tree constraint.InstructionTree) constraint.Level {
	maxLevel := constraint.LevelUnset

	// Parse wireI and instanceI (skip them)
	offset := 2

	// Parse dependency linear expression
	// This ensures we run after the solve instruction for this instance
	n := int(inst.Calldata[offset])
	offset++

	for range n {
		wireID := inst.Calldata[offset+1]
		offset += 2
		if !tree.HasWire(wireID) {
			continue
		}
		if level := tree.GetWireLevel(wireID); level > maxLevel {
			maxLevel = level
		}
	}

	outputLevel := maxLevel + 1
	tree.InsertWire(inst.WireOffset, outputLevel)
	return outputLevel
}

// NewBlueprints creates and registers all GKR blueprints for BLS12_381
func NewBlueprints(circuit gkrtypes.SerializableCircuit, hashName string, compiler constraint.CustomizableSystem) gadget.Blueprints {
	// Create and register solve blueprint
	solve := &BlueprintSolve{Circuit: circuit}
	solveID := compiler.AddBlueprint(solve)

	// Create and register prove blueprint
	prove := &BlueprintProve{
		SolveBlueprintID: solveID,
		SolveBlueprint:   solve,
		HashName:         hashName,
	}
	proveID := compiler.AddBlueprint(prove)

	// Create and register GetAssignment blueprint
	getAssignment := &BlueprintGetAssignment{
		SolveBlueprintID: solveID,
		SolveBlueprint:   solve,
	}
	getAssignmentID := compiler.AddBlueprint(getAssignment)

	return gadget.Blueprints{
		SolveID:         solveID,
		Solve:           solve,
		ProveID:         proveID,
		GetAssignmentID: getAssignmentID,
	}
}
