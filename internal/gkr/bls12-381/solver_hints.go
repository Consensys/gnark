// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package gkr

import (
	"fmt"
	"math/big"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/hash"
	hint "github.com/consensys/gnark/constraint/solver"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/internal/gkr/gkrtypes"
	algo_utils "github.com/consensys/gnark/internal/utils"

	"github.com/consensys/gnark-crypto/ecc/bls12-381/fr"
	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
)

type SolvingData struct {
	assignment  WireAssignment // assignment is indexed wire-first, instance-second. The number of instances is padded to a power of 2.
	circuit     gkrtypes.Circuit
	maxNbIn     int // maximum number of inputs for a gate in the circuit
	nbInstances int
}

type newSolvingDataSettings struct {
	assignment gkrtypes.WireAssignment
}

type newSolvingDataOption func(*newSolvingDataSettings)

func WithAssignment(assignment gkrtypes.WireAssignment) newSolvingDataOption {
	return func(s *newSolvingDataSettings) {
		s.assignment = assignment
	}
}

func NewSolvingData(info gkrtypes.SolvingInfo, options ...newSolvingDataOption) *SolvingData {
	var s newSolvingDataSettings
	for _, opt := range options {
		opt(&s)
	}

	d := SolvingData{
		circuit:     info.Circuit,
		assignment:  make(WireAssignment, len(info.Circuit)),
		nbInstances: info.NbInstances,
	}

	d.maxNbIn = d.circuit.MaxGateNbIn()

	nbPaddedInstances := int(ecc.NextPowerOfTwo(uint64(info.NbInstances)))
	for i := range d.assignment {
		d.assignment[i] = make([]fr.Element, nbPaddedInstances)
	}

	if s.assignment != nil {
		if len(s.assignment) != len(d.assignment) {
			panic(fmt.Errorf("provided assignment has %d wires, expected %d", len(s.assignment), len(d.assignment)))
		}
		for i := range d.assignment {
			if len(s.assignment[i]) != info.NbInstances {
				panic(fmt.Errorf("provided assignment for wire %d has %d instances, expected %d", i, len(s.assignment[i]), info.NbInstances))
			}
			for j := range s.assignment[i] {
				if _, err := d.assignment[i][j].SetInterface(s.assignment[i][j]); err != nil {
					panic(fmt.Errorf("provided assignment for wire %d instance %d is not a valid field element: %w", i, j, err))
				}
			}
			// inline equivalent of RepeatUntilEnd
			for j := len(s.assignment[i]); j < nbPaddedInstances; j++ {
				d.assignment[i][j] = d.assignment[i][j-1] // pad with the last value
			}
		}
	}

	return &d
}

// this module assumes that wire and instance indexes respect dependencies

func GetAssignmentHint(data *SolvingData) hint.Hint {
	return func(_ *big.Int, ins, outs []*big.Int) error {
		if len(ins) != 3 {
			return fmt.Errorf("GetAssignmentHint expects 3 inputs: wire index, instance index, and dummy dependency enforcer")
		}
		wireI := ins[0].Uint64()
		instanceI := ins[1].Uint64()

		data.assignment[wireI][instanceI].BigInt(outs[0])

		return nil
	}
}

func SolveHint(data *SolvingData) hint.Hint {
	return func(_ *big.Int, ins, outs []*big.Int) error {
		instanceI := ins[0].Uint64()

		gateIns := make([]frontend.Variable, data.maxNbIn)
		outsI := 0
		insI := 1       // skip the first input, which is the instance index
		var api gateAPI // since the api is synchronous, we can't share it across Solve Hint invocations.
		for wI := range data.circuit {
			w := &data.circuit[wI]
			if w.IsInput() { // read from provided input
				data.assignment[wI][instanceI].SetBigInt(ins[insI])
				insI++
			} else {

				// assemble input for gate
				for i, inWI := range w.Inputs {
					gateIns[i] = &data.assignment[inWI][instanceI]
				}

				data.assignment[wI][instanceI].Set(w.Gate.Evaluate(&api, gateIns[:len(w.Inputs)]...).(*fr.Element))
			}
			if w.IsOutput() {
				data.assignment[wI][instanceI].BigInt(outs[outsI])
				outsI++
			}
		}

		return nil
	}
}

func ProveHint(hashName string, data *SolvingData) hint.Hint {

	return func(_ *big.Int, ins, outs []*big.Int) error {

		data.assignment.RepeatUntilEnd(data.nbInstances)

		// The first input is dummy, just to ensure the solver's work is done before the prover is called.
		// The rest constitute the initial fiat shamir challenge
		insBytes := algo_utils.Map(ins[1:], func(i *big.Int) []byte {

			b := make([]byte, fr.Bytes)
			i.FillBytes(b)
			return b[:]
		})

		hsh := hash.NewHash(hashName + "_BLS12_381")

		proof, err := Prove(data.circuit, data.assignment, fiatshamir.WithHash(hsh, insBytes...))
		if err != nil {
			return err
		}

		return proof.SerializeToBigInts(outs)

	}
}

// RepeatUntilEnd for each wire, sets all the values starting from n > 0 to its predecessor.
// e.g. {{1, 2, 3}, {4, 5, 6}}.RepeatUntilEnd(2) -> {{1, 2, 2}, {4, 5, 5}}
func (a WireAssignment) RepeatUntilEnd(n int) {
	for i := range a {
		for j := n; j < len(a[i]); j++ {
			a[i][j] = a[i][j-1]
		}
	}
}
