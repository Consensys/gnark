// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package gkr

import (
	"fmt"
	"math/big"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/hash"
	hint "github.com/consensys/gnark/constraint/solver"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/internal/gkr/gkrtypes"
	algo_utils "github.com/consensys/gnark/internal/utils"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
)

type SolvingData struct {
	assignment  WireAssignment // assignment is indexed wire-first, instance-second. The number of instances is padded to a power of 2.
	circuit     gkrtypes.Circuit
	maxNbIn     int // maximum number of inputs for a gate in the circuit
	nbInstances int
	hashName    string
}

type newSolvingDataSettings struct {
	assignment gkrtypes.WireAssignment
}

type NewSolvingDataOption func(*newSolvingDataSettings)

// WithAssignment re-use already computed wire assignments.
func WithAssignment(assignment gkrtypes.WireAssignment) NewSolvingDataOption {
	return func(s *newSolvingDataSettings) {
		s.assignment = assignment
	}
}

// NewSolvingData converts []gkrtypes.SolvingInfo into concrete SolvingData objects:
// - The gates are loaded in accordance with their names.
// - The instances/assignments are padded into a power of 2, suitable for the multilinear extensions used
// in the GKR prover.
func NewSolvingData(info []gkrtypes.SolvingInfo, options ...NewSolvingDataOption) []SolvingData {
	var s newSolvingDataSettings
	for _, opt := range options {
		opt(&s)
	}

	d := make([]SolvingData, len(info))

	for k := range info {

		d[k].circuit = info[k].Circuit
		d[k].assignment = make(WireAssignment, len(info[k].Circuit))
		d[k].nbInstances = info[k].NbInstances
		d[k].hashName = info[k].HashName

		d[k].maxNbIn = d[k].circuit.MaxGateNbIn()

		nbPaddedInstances := int(ecc.NextPowerOfTwo(uint64(info[k].NbInstances)))
		for i := range d[k].assignment {
			d[k].assignment[i] = make([]fr.Element, nbPaddedInstances)
		}

		if s.assignment != nil {
			if len(s.assignment) != len(d[k].assignment) {
				panic(fmt.Sprintf("provided assignment has %d wires, expected %d", len(s.assignment), len(d[k].assignment)))
			}
			for i := range d[k].assignment {
				if len(s.assignment[i]) != info[k].NbInstances {
					panic(fmt.Sprintf("provided assignment for wire %d has %d instances, expected %d", i, len(s.assignment[i]), info[k].NbInstances))
				}
				for j := range s.assignment[i] {
					if _, err := d[k].assignment[i][j].SetInterface(s.assignment[i][j]); err != nil {
						panic(fmt.Sprintf("provided assignment for wire %d instance %d is not a valid field element: %v", i, j, err))
					}
				}
				// inline equivalent of repeatUntilEnd
				for j := len(s.assignment[i]); j < nbPaddedInstances; j++ {
					d[k].assignment[i][j] = d[k].assignment[i][j-1] // pad with the last value
				}
			}
		}
	}

	return d
}

// this module assumes that wire and instance indexes respect dependencies

// GetAssignmentHint generates a hint that returns the value of a wire of a circuit at an instance.
// It is intended for use in the debugging function gkrapi.API.GetValue.
func GetAssignmentHint(data []SolvingData) hint.Hint {
	return func(_ *big.Int, ins, outs []*big.Int) error {
		if len(ins) != 4 {
			return fmt.Errorf("GetAssignmentHint expects 3 inputs: GKR sub-circuit index, wire index, instance index, and dummy dependency enforcer")
		}
		if !ins[0].IsUint64() || !ins[1].IsUint64() || !ins[2].IsUint64() {
			return fmt.Errorf("all 3 non-dummy input to GetAssignmentHint must fit in uint64")
		}
		data := data[ins[0].Uint64()]
		wireI := ins[1].Uint64()
		instanceI := ins[2].Uint64()

		data.assignment[wireI][instanceI].BigInt(outs[0])

		return nil
	}
}

// SolveHint generate a hint that computes the assignments for all wires in a circuit instance.
// It is intended for use in gkrapi.API.AddInstance.
func SolveHint(data []SolvingData) hint.Hint {
	return func(_ *big.Int, ins, outs []*big.Int) error {
		if !ins[0].IsUint64() {
			return fmt.Errorf("first input to GKR prove hint must be the sub-circuit index")
		}
		data := data[ins[0].Uint64()]

		instanceI := ins[1].Uint64()

		gateIns := make([]frontend.Variable, data.maxNbIn)
		outsI := 0
		insI := 2 // skip the first two input, which are the circuit and instance indices, respectively.
		for wI := range data.circuit {
			w := &data.circuit[wI]
			if w.IsInput() { // read from provided input
				data.assignment[wI][instanceI].SetBigInt(ins[insI])
				insI++
			} else {

				// assemble input for gate
				for i, inWI := range w.Inputs {
					gateIns[i] = &data.assignment[inWI][instanceI]
				}

				data.assignment[wI][instanceI].Set(w.Gate.Evaluate(api, gateIns[:len(w.Inputs)]...).(*fr.Element))
			}
			if w.IsOutput() {
				data.assignment[wI][instanceI].BigInt(outs[outsI])
				outsI++
			}
		}

		return nil
	}
}

// ProveHint generates a hint that produces the GKR proof using the computed assignments contained in data.
// It is meant for use in gkrapi.Circuit.finalize.
func ProveHint(data []SolvingData) hint.Hint {

	return func(_ *big.Int, ins, outs []*big.Int) error {
		if !ins[0].IsUint64() {
			return fmt.Errorf("first input to GKR prove hint must be the sub-circuit index")
		}
		data := data[ins[0].Uint64()]
		hashName := data.hashName
		ins = ins[1:]

		data.assignment.repeatUntilEnd(data.nbInstances)

		// The second input is dummy, just to ensure the solver's work is done before the prover is called.
		// The rest constitute the initial fiat shamir challenge
		insBytes := algo_utils.Map(ins[1:], func(i *big.Int) []byte {

			b := make([]byte, fr.Bytes)
			i.FillBytes(b)
			return b[:]
		})

		hsh := hash.NewHash(hashName + "_BN254")

		proof, err := Prove(data.circuit, data.assignment, fiatshamir.WithHash(hsh, insBytes...))
		if err != nil {
			return err
		}

		return proof.SerializeToBigInts(outs)

	}
}

// repeatUntilEnd for each wire, sets all the values starting from n > 0 to its predecessor.
// e.g. {{1, 2, 3}, {4, 5, 6}}.repeatUntilEnd(2) -> {{1, 2, 2}, {4, 5, 5}}
func (a WireAssignment) repeatUntilEnd(n int) {
	for i := range a {
		for j := n; j < len(a[i]); j++ {
			a[i][j] = a[i][j-1]
		}
	}
}
