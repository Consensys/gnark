// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package gkr

import (
	"fmt"
	"math/big"

	"github.com/consensys/gnark-crypto/hash"
	"github.com/consensys/gnark-crypto/utils"
	hint "github.com/consensys/gnark/constraint/solver"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/internal/gkr/gkrinfo"
	"github.com/consensys/gnark/internal/gkr/gkrtypes"
	algo_utils "github.com/consensys/gnark/internal/utils"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
)

type SolvingData struct {
	assignment       WireAssignment
	circuit          gkrtypes.Circuit
	workers          *utils.WorkerPool
	maxNbIn          int // maximum number of inputs for a gate in the circuit
	printsByInstance map[uint32][]gkrinfo.PrintInfo
}

func NewSolvingData(info gkrtypes.SolvingInfo) *SolvingData {
	d := SolvingData{
		workers:          utils.NewWorkerPool(),
		circuit:          info.Circuit,
		assignment:       make(WireAssignment, len(info.Circuit)),
		printsByInstance: gkrinfo.NewPrintInfoMap(info.Prints),
	}

	d.circuit.SetNbUniqueOutputs()
	d.maxNbIn = d.circuit.MaxGateNbIn()

	for i := range d.assignment {
		d.assignment[i] = make([]fr.Element, info.NbInstances)
	}

	return &d
}

// this module assumes that wire and instance indexes respect dependencies

func SolveHint(data *SolvingData) hint.Hint {
	return func(_ *big.Int, ins, outs []*big.Int) error {
		instanceI := ins[0].Uint64()
		if !ins[0].IsUint64() { // TODO use idiomatic printf tag
			return fmt.Errorf("first input to solving hint must be the instance index; provided value %s doesn't fit in 64 bits", ins[0])
		}

		gateIns := make([]frontend.Variable, data.maxNbIn)
		outsI := 0
		insI := 1 // skip the first input, which is the instance index
		for wI := range data.circuit {
			w := &data.circuit[wI]
			if w.IsInput() { // read from provided input
				data.assignment[wI][instanceI].SetBigInt(ins[insI])
				insI++
			} else {

				// assemble input for gate
				for i, inWI := range w.Inputs {
					gateIns[i] = &data.assignment[inWI][instanceI]
				}

				data.assignment[wI][instanceI].Set(w.Gate.Evaluate(api, gateIns[:len(w.Inputs)]...).(*fr.Element))
			}
			if w.IsOutput() {
				data.assignment[wI][instanceI].BigInt(outs[outsI])
				outsI++
			}
		}

		prints := data.printsByInstance[uint32(instanceI)]
		delete(data.printsByInstance, uint32(instanceI))
		for _, p := range prints {
			serializable := make([]any, len(p.Values))
			for i, v := range p.Values {
				if p.IsGkrVar[i] { // serializer stores uint32 in slices as uint64
					serializable[i] = data.assignment[algo_utils.ForceUint32(v)][p.Instance].String()
				} else {
					serializable[i] = v
				}
			}
			fmt.Println(serializable...)
		}
		return nil
	}
}

func ProveHint(hashName string, data *SolvingData) hint.Hint {

	return func(_ *big.Int, ins, outs []*big.Int) error {
		insBytes := algo_utils.Map(ins[1:], func(i *big.Int) []byte { // the first input is dummy, just to ensure the solver's work is done before the prover is called
			b := make([]byte, fr.Bytes)
			i.FillBytes(b)
			return b[:]
		})

		hsh := hash.NewHash(hashName + "_BN254")

		proof, err := Prove(data.circuit, data.assignment, fiatshamir.WithHash(hsh, insBytes...), WithWorkers(data.workers))
		if err != nil {
			return err
		}

		return proof.SerializeToBigInts(outs)

	}
}
