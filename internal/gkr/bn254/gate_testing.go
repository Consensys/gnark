// Copyright 2020-2026 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by gnark DO NOT EDIT

package gkr

import (
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/internal/gkr/gkrtypes"

	"slices"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/fft"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/polynomial"
)

type GateTester struct {
	evaluator gateEvaluator
	nbIn      int
}

func (t *GateTester) SetGate(g *gkrtypes.GateBytecode, nbIn int) {
	t.evaluator = newGateEvaluator(g, nbIn)
	t.nbIn = nbIn
}

// IsAdditive returns whether xáµ¢ occurs only in a monomial of total degree 1 in e
func (t *GateTester) IsAdditive(i int) bool {

	// fix all variables except the i-th one at random points
	// pick random value x1 for the i-th variable
	// check if f(-, 0, -) + f(-, 2*x1, -) = 2*f(-, x1, -)
	x := make(fr.Vector, t.nbIn)
	x.MustSetRandom()
	x0 := x[i]
	x[i].SetZero()
	in := slices.Clone(x)
	y0 := *t.evaluator.evaluate(in...)

	x[i] = x0
	copy(in, x)
	y1 := *t.evaluator.evaluate(in...)

	x[i].Double(&x[i])
	copy(in, x)
	y2 := *t.evaluator.evaluate(in...)

	y2.Sub(&y2, &y1)
	y1.Sub(&y1, &y0)

	if !y2.Equal(&y1) {
		return false // not linear
	}

	// check if the coefficient of x_i is nonzero and independent of the other variables (so that we know it is ALWAYS nonzero)
	if y1.IsZero() { // f(-, x1, -) = f(-, 0, -), so the coefficient of x_i is 0
		return false
	}

	// compute the slope with another assignment for the other variables
	x.MustSetRandom()
	x[i].SetZero()
	copy(in, x)
	y0 = *t.evaluator.evaluate(in...)

	x[i] = x0
	copy(in, x)
	y1 = *t.evaluator.evaluate(in...)
	y1.Sub(&y1, &y0)

	return y1.Equal(&y2)
}

// fitPoly tries to fit a polynomial of degree less than degreeBound to the gate.
// degreeBound must be a power of 2.
// It returns the polynomial if successful, nil otherwise
func (t *GateTester) fitPoly(degreeBound uint64) polynomial.Polynomial {

	// turn f univariate by defining p(x) as f(x, rx, ..., sx)
	// where r, s, ... are random constants
	fIn := make([]fr.Element, t.nbIn)
	consts := make(fr.Vector, t.nbIn-1)
	consts.MustSetRandom()

	p := make(polynomial.Polynomial, degreeBound)
	domain := fft.NewDomain(degreeBound)
	// evaluate p on the unit circle (first filling p with evaluations rather than coefficients)
	x := fr.One()
	for i := range p {
		fIn[0] = x
		for j := range consts {
			fIn[j+1].Mul(&x, &consts[j])
		}
		p[i].Set(t.evaluator.evaluate(fIn...))

		x.Mul(&x, &domain.Generator)
	}

	// obtain p's coefficients
	domain.FFTInverse(p, fft.DIF)
	fft.BitReverse(p) //nolint:staticcheck // method is backwards compatible

	// check if p is equal to f. This not being the case means that f is of a degree higher than degreeBound
	fIn[0].MustSetRandom()
	for i := range consts {
		fIn[i+1].Mul(&fIn[0], &consts[i])
	}
	pAt := p.Eval(&fIn[0])
	fAt := *t.evaluator.evaluate(fIn...)
	if !pAt.Equal(&fAt) {
		return nil
	}

	// trim p
	lastNonZero := len(p) - 1
	for lastNonZero >= 0 && p[lastNonZero].IsZero() {
		lastNonZero--
	}
	return p[:lastNonZero+1]
}

// FindDegree returns the degree of the gate function, or -1 if it fails.
// Failure can be due to the function not being a polynomial at all, or being constantly zero.
func (t *GateTester) FindDegree() int {
	p := t.fitPoly(ecc.NextPowerOfTwo(uint64(t.evaluator.gate.EstimateDegree(t.nbIn)) + 1))
	return len(p) - 1
}
