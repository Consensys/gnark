import (
	"fmt"
	"math/big"
	"math/bits"
	"sync"

	"{{ .FieldPackagePath }}"
	"{{ .FieldPackagePath }}/polynomial"
	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark-crypto/hash"
	"github.com/consensys/gnark/constraint"
	gadget "github.com/consensys/gnark/internal/gkr"
	"github.com/consensys/gnark/internal/gkr/gkrtypes"
)

// circuitEvaluator evaluates all gates in a circuit for one instance
type circuitEvaluator struct {
	evaluators []gateEvaluator // one evaluator per wire
}

// BlueprintSolve is a {{.FieldID}}-specific blueprint for solving GKR circuit instances.
type BlueprintSolve struct {
	// Circuit structure (serialized)
	Circuit     gkrtypes.Circuit
	NbInstances int

	// Not serialized - recreated lazily at solve time
	assignment    WireAssignment `cbor:"-"` // []polynomial.MultiLin
	evaluatorPool sync.Pool      `cbor:"-"` // pool of circuitEvaluator, lazy-initialized
	nbInputs      int            `cbor:"-"`
	nbOutputVars  int            `cbor:"-"`
	inputWires    []int          `cbor:"-"`
	outputWires   []int          `cbor:"-"`
	maxNbIn       int            `cbor:"-"` // maximum number of inputs for any gate

	lock sync.Mutex `cbor:"-"`
}

// Ensures BlueprintSolve implements BlueprintStateful
var _ constraint.BlueprintStateful[constraint.U64] = (*BlueprintSolve)(nil)

func (b *BlueprintSolve) initialize() {

	if b.assignment != nil {
		return
	}
	b.lock.Lock()
	defer b.lock.Unlock()

	if b.assignment != nil {
		return	// the unlikely event that two or more instructions were competing to initialize the blueprint
	}

	// Compute metadata from Circuit
	b.maxNbIn = b.Circuit.MaxGateNbIn()
	for i := range b.Circuit {
		if b.Circuit[i].IsInput() {
			b.nbInputs++
			b.inputWires = append(b.inputWires, i)
		}
	}

	// Identify output wires (not inputs to any other wire)
	isOutput := make([]bool, len(b.Circuit))
	for i := range b.Circuit {
		isOutput[i] = true
	}
	for _, w := range b.Circuit {
		for _, inIdx := range w.Inputs {
			isOutput[inIdx] = false
		}
	}
	for i := range b.Circuit {
		if isOutput[i] {
			b.nbOutputVars++
			b.outputWires = append(b.outputWires, i)
		}
	}

	b.evaluatorPool.New = func() interface{} {
		ce := &circuitEvaluator{
			evaluators: make([]gateEvaluator, len(b.Circuit)),
		}
		for wI := range b.Circuit {
			w := &b.Circuit[wI]
			if !w.IsInput() {
				ce.evaluators[wI] = newGateEvaluator(w.Gate.Compiled(), len(w.Inputs))
			}
		}
		return ce
	}

	b.assignment = make(WireAssignment, len(b.Circuit))
	for i := range b.assignment {
		b.assignment[i] = make(polynomial.MultiLin, b.NbInstances)
	}
}

// Solve implements the BlueprintStateful interface.
func (b *BlueprintSolve) Solve(s constraint.Solver[constraint.U64], inst constraint.Instruction) error {

	b.initialize()

	// Get a circuit evaluator from the pool
	ce := b.evaluatorPool.Get().(*circuitEvaluator)
	defer b.evaluatorPool.Put(ce)

	instanceI := int(inst.Calldata[0])
	calldata := inst.Calldata[1:]

	// Process all wires in topological order (circuit is already sorted)
	for wI := range b.Circuit {
		w := &b.Circuit[wI]

		if w.IsInput() {
			val, delta := s.Read(calldata)
			calldata = calldata[delta:]
			// Copy directly from constraint.U64 to fr.Element (both in Montgomery form)
			copy(b.assignment[wI][instanceI][:], val[:])
		} else {
			// Get evaluator for this wire from the circuit evaluator
			evaluator := &ce.evaluators[wI]

			// Push gate inputs
			for _, inWI := range w.Inputs {
				evaluator.pushInput(&b.assignment[inWI][instanceI])
			}

			// Evaluate the gate
			b.assignment[wI][instanceI].Set(evaluator.evaluate())
		}
	}

	// Set output wires (copy fr.Element to U64 in Montgomery form)
	for outI, outWI := range b.outputWires {
		var val constraint.U64
		copy(val[:], b.assignment[outWI][instanceI][:])
		s.SetValue(uint32(outI+int(inst.WireOffset)), val)
	}

	return nil
}

// Reset implements BlueprintStateful
func (b *BlueprintSolve) Reset() {
	b.assignment = nil
}

// CalldataSize implements Blueprint
func (b *BlueprintSolve) CalldataSize() int {
	return -1 // variable size
}

// NbConstraints implements Blueprint
func (b *BlueprintSolve) NbConstraints() int {
	return 0
}

// NbOutputs implements Blueprint
func (b *BlueprintSolve) NbOutputs(inst constraint.Instruction) int {
	return b.nbOutputVars
}

// UpdateInstructionTree implements Blueprint
func (b *BlueprintSolve) UpdateInstructionTree(inst constraint.Instruction, tree constraint.InstructionTree) constraint.Level {
	maxLevel := constraint.LevelUnset

	// Parse exactly b.nbInputs linear expressions
	offset := 1 // skip instance index
	for range b.nbInputs {
		n := int(inst.Calldata[offset])
		offset++

		for range n {
			wireID := inst.Calldata[offset+1]
			offset += 2
			if !tree.HasWire(wireID) {
				continue
			}
			if level := tree.GetWireLevel(wireID); level > maxLevel {
				maxLevel = level
			}
		}
	}

	outputLevel := maxLevel + 1
	for i := range b.nbOutputVars {
		tree.InsertWire(uint32(i+int(inst.WireOffset)), outputLevel)
	}

	return outputLevel
}

// GetAssignment returns the assignment for a specific wire and instance (for debugging)
func (b *BlueprintSolve) GetAssignment(s constraint.Solver[constraint.U64], wireIdx, instanceIdx int) (constraint.U64, error) {
	b.lock.Lock()
	defer b.lock.Unlock()

	var zero constraint.U64
	if wireIdx >= len(b.assignment) || instanceIdx >= len(b.assignment[wireIdx]) {
		return zero, fmt.Errorf("wire %d instance %d out of bounds", wireIdx, instanceIdx)
	}

	// Convert {{ .ElementType }} to U64
	var bigInt big.Int
	b.assignment[wireIdx][instanceIdx].BigInt(&bigInt)
	return s.FromInterface(&bigInt), nil
}

// GetAssignments returns all assignments for proving
func (b *BlueprintSolve) GetAssignments() WireAssignment {
	b.lock.Lock()
	defer b.lock.Unlock()
	return b.assignment
}

// GetNbInstances returns the number of instances (compile-time)
func (b *BlueprintSolve) GetNbInstances() int {
	return b.NbInstances
}

// BlueprintProve is a {{.FieldID}}-specific blueprint for generating GKR proofs.
type BlueprintProve struct {
	SolveBlueprintID constraint.BlueprintID
	SolveBlueprint   *BlueprintSolve `cbor:"-"` // not serialized, set at compile time
	HashName         string

	lock sync.Mutex
}

// Ensures BlueprintProve implements BlueprintSolvable
var _ constraint.BlueprintSolvable[constraint.U64] = (*BlueprintProve)(nil)

// Solve implements the BlueprintSolvable interface for proving.
func (b *BlueprintProve) Solve(s constraint.Solver[constraint.U64], inst constraint.Instruction) error {
	b.lock.Lock()
	defer b.lock.Unlock()

	// Get solve blueprint from solver by ID
	solveBlueprint := s.GetBlueprint(b.SolveBlueprintID).(*BlueprintSolve)

	// Get assignments from solve blueprint (already in {{ .ElementType }} form)
	assignments := solveBlueprint.GetAssignments()
	if len(assignments) == 0 {
		return fmt.Errorf("no assignments available for proving")
	}

	// Read initial challenges from instruction calldata (parse dynamically, no metadata)
	insBytes := make([][]byte, 0) // first challenges
	calldata := inst.Calldata
	for len(calldata) != 0 {
		val, delta := s.Read(calldata)
		calldata = calldata[delta:]

		// Copy directly from constraint.U64 to fr.Element (both in Montgomery form)
		var challenge {{ .ElementType }}
		copy(challenge[:], val[:])
		insBytes = append(insBytes, challenge.Marshal())
	}

	// Create Fiat-Shamir settings
	hsh := hash.NewHash(b.HashName + "_{{.FieldID}}")
	fsSettings := fiatshamir.WithHash(hsh, insBytes...)

	// Call the {{.FieldID}}-specific Prove function (assignments already WireAssignment type)
	proof, err := Prove(solveBlueprint.Circuit, assignments, fsSettings)
	if err != nil {
		return fmt.Errorf("{{toLower .FieldID}} prove failed: %w", err)
	}

	// Serialize proof and convert to U64
	proofSize := 0
	for i := range proof {
		for _, poly := range proof[i].partialSumPolys {
			proofSize += len(poly)
		}
		if proof[i].finalEvalProof != nil {
			proofSize += len(proof[i].finalEvalProof)
		}
	}

	outsBig := make([]*big.Int, proofSize)
	for i := range outsBig {
		outsBig[i] = new(big.Int)
	}
	if err := proof.SerializeToBigInts(outsBig); err != nil {
		return fmt.Errorf("failed to serialize proof: %w", err)
	}

	// Set output wires (convert big.Int to U64)
	for i, bigVal := range outsBig {
		s.SetValue(uint32(i+int(inst.WireOffset)), s.FromInterface(bigVal))
	}

	return nil
}

// CalldataSize implements Blueprint
func (b *BlueprintProve) CalldataSize() int {
	return -1 // variable size
}

// NbConstraints implements Blueprint
func (b *BlueprintProve) NbConstraints() int {
	return 0
}

// NbOutputs implements Blueprint
func (b *BlueprintProve) NbOutputs(inst constraint.Instruction) int {
	// Compute proof size from blueprint state
	nbInstances := b.SolveBlueprint.GetNbInstances()
	if nbInstances == 0 {
		return 0
	}
	logNbInstances := bits.TrailingZeros(uint(nbInstances))
	return gadget.ProofSize(b.SolveBlueprint.Circuit, logNbInstances)
}

// UpdateInstructionTree implements Blueprint
func (b *BlueprintProve) UpdateInstructionTree(inst constraint.Instruction, tree constraint.InstructionTree) constraint.Level {
	maxLevel := constraint.LevelUnset

	// Parse all challenges dynamically (no metadata)
	offset := 0
	for offset < len(inst.Calldata) {
		n := int(inst.Calldata[offset])
		offset++

		for range n {
			wireID := inst.Calldata[offset+1]
			offset += 2
			if !tree.HasWire(wireID) {
				continue
			}
			if level := tree.GetWireLevel(wireID); level > maxLevel {
				maxLevel = level
			}
		}
	}

	outputLevel := maxLevel + 1
	// Compute proof size from blueprint state
	nbInstances := b.SolveBlueprint.GetNbInstances()
	if nbInstances > 0 {
		logNbInstances := bits.TrailingZeros(uint(nbInstances))
		proofSize := gadget.ProofSize(b.SolveBlueprint.Circuit, logNbInstances)
		for i := range proofSize {
			tree.InsertWire(uint32(i+int(inst.WireOffset)), outputLevel)
		}
	}

	return outputLevel
}
