{{define "gkrTestVectors"}}

{{$CheckOutputCorrectness := true}}

type PrintableProof []PrintableSumcheckProof

type PrintableSumcheckProof struct {
	FinalEvalProof  interface{}     `json:"finalEvalProof"`
	PartialSumPolys [][]interface{} `json:"partialSumPolys"`
}

func unmarshalProof(printable PrintableProof) (Proof, error) {
	proof := make(Proof, len(printable))
	for i := range printable {
		finalEvalProof := []{{.ElementType}}(nil)

		if printable[i].FinalEvalProof != nil {
			finalEvalSlice := reflect.ValueOf(printable[i].FinalEvalProof)
			finalEvalProof = make([]{{.ElementType}}, finalEvalSlice.Len())
			for k := range finalEvalProof {
				if _, err := {{ setElement "finalEvalProof[k]" "finalEvalSlice.Index(k).Interface()" .ElementType}}; err != nil {
					return nil, err
				}
			}
		}

		proof[i] = sumcheckProof{
			partialSumPolys: make([]polynomial.Polynomial, len(printable[i].PartialSumPolys)),
			finalEvalProof:  finalEvalProof,
		}
		for k := range printable[i].PartialSumPolys {
			var err error
			if proof[i].partialSumPolys[k], err = sliceToElementSlice(printable[i].PartialSumPolys[k]); err != nil {
				return nil, err
			}
		}
	}
	return proof, nil
}

type TestCase struct {
	Circuit         Circuit
	Hash            hash.Hash
	Proof           Proof
	FullAssignment  WireAssignment
	InOutAssignment WireAssignment
	{{if .GenerateTestVectors}}Info TestCaseInfo // we are generating the test vectors, so we need to keep the circuit instance info to ADD the proof to it and resave it{{end}}
}

type TestCaseInfo struct {
	Hash    hashDescription `json:"hash"`
	Circuit string                            `json:"circuit"`
	Input   [][]interface{}                   `json:"input"`
	Output  [][]interface{}                   `json:"output"`
	Proof   PrintableProof                    `json:"proof"`
}

var testCases = make(map[string]*TestCase)

func newTestCase(path string) (*TestCase, error) {
	path, err := filepath.Abs(path)
	if err != nil {
		return nil, err
	}
	dir := filepath.Dir(path)

	tCase, ok := testCases[path]
	if !ok {
		var bytes []byte
		if bytes, err = os.ReadFile(path); err == nil {
			var info TestCaseInfo
			err = json.Unmarshal(bytes, &info)
			if err != nil {
				return nil, err
			}

			var circuit Circuit
			if circuit, err = getCircuit(filepath.Join(dir, info.Circuit)); err != nil {
				return nil, err
			}
			var _hash hash.Hash
			if _hash, err = hashFromDescription(info.Hash); err != nil {
				return nil, err
			}
			var proof Proof
			if proof, err = unmarshalProof(info.Proof); err != nil {
				return nil, err
			}

			fullAssignment := make(WireAssignment)
			inOutAssignment := make(WireAssignment)

			sorted := topologicalSort(circuit)

			inI, outI := 0, 0
			for _, w := range sorted {
				var assignmentRaw []interface{}
				if w.IsInput() {
					if inI == len(info.Input) {
						return nil, fmt.Errorf("fewer input in vector than in circuit")
					}
					assignmentRaw = info.Input[inI]
					inI++
				} else if w.IsOutput() {
					if outI == len(info.Output) {
						return nil, fmt.Errorf("fewer output in vector than in circuit")
					}
					assignmentRaw = info.Output[outI]
					outI++
				}
				if assignmentRaw != nil {
					var wireAssignment []{{.ElementType}}
					if wireAssignment, err = sliceToElementSlice(assignmentRaw); err != nil {
					return nil, err
					}

					fullAssignment[w] = wireAssignment
					inOutAssignment[w] = wireAssignment
				}
			}

			fullAssignment.Complete(circuit)

			{{if not $CheckOutputCorrectness}}
				info.Output = make([][]interface{}, 0, outI)
			{{end}}

			for _, w := range sorted {
				if w.IsOutput() {
				{{if $CheckOutputCorrectness}}
					if err = sliceEquals(inOutAssignment[w], fullAssignment[w]); err != nil {
						return nil, fmt.Errorf("assignment mismatch: %v", err)
					}
				{{else}}
					info.Output = append(info.Output, elementSliceToInterfaceSlice(inOutAssignment[w]))
				{{end}}
				}
			}

			tCase = &TestCase{
				FullAssignment:  fullAssignment,
				InOutAssignment: inOutAssignment,
				Proof:           proof,
				Hash:            _hash,
				Circuit:         circuit,
				{{if .GenerateTestVectors }}Info: info,{{end}}
			}

			testCases[path] = tCase
		} else {
			return nil, err
		}
	}

	return tCase, nil
}

{{end}}

{{- define "setElement element value elementType"}}
{{- if eq .elementType "fr.Element"}} setElement(&{{.element}}, {{.value}})
{{- else if eq .elementType "small_rational.SmallRational"}} {{.element}}.SetInterface({{.value}})
{{- else}}
{{print "\"UNEXPECTED TYPE" .elementType "\""}}
{{- end}}
{{- end}}