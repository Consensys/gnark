import (
    "reflect"
    "fmt"
    "io"
    "strings"
    "encoding/binary"

    "github.com/consensys/gnark/frontend/schema"

	{{ template "import_fr" . }}
)

type Witness []fr.Element

// WriteTo encodes witness to writer (implements io.WriterTo)
func (witness *Witness) WriteTo(w io.Writer) (int64, error) {
    // encode slice length
    if err := binary.Write(w, binary.BigEndian, uint32(len(*witness))); err != nil {
        return 0, err 
    }

	n := int64(4)

	var buf [fr.Bytes]byte 
	for i := 0; i < len(*witness); i++ {
		buf = (*witness)[i].Bytes() 
		m, err := w.Write(buf[:])
		n += int64(m)
		if err != nil {
			return n, err 
		} 
	}
	return n, nil
}

func (witness *Witness) Len() int {
    return len(*witness)
}

func (witness *Witness) Type() reflect.Type {
    return reflect.TypeOf(fr.Element{})
}


func (witness *Witness) ReadFrom(r io.Reader) (int64, error) {

	var buf [fr.Bytes]byte 
	if read, err := io.ReadFull(r, buf[:4]); err != nil {
        return int64(read), err 
    }
	sliceLen := binary.BigEndian.Uint32(buf[:4])

    n := int64(4)

    if len(*witness) != int(sliceLen) {
        *witness = make([]fr.Element, sliceLen)
    }

    for i:=0; i < int(sliceLen); i++ {
        read, err := io.ReadFull(r, buf[:])
        n += int64(read)
        if err != nil {
            return n, err
        }
        (*witness)[i].SetBytes(buf[:])
    }
	

    return n, nil 
}


// FromAssignment extracts the witness and its schema
func (witness *Witness) FromAssignment(assignment interface{}, leafType reflect.Type, publicOnly bool) (*schema.Schema, error)  {
    s, err := schema.ParseDeprecated(assignment, leafType, nil)
    if err != nil {
        return nil, err 
    }
    nbSecret, nbPublic := s.NbSecret, s.NbPublic

    if publicOnly {
        nbSecret = 0
    }

    if len(*witness) < (nbPublic + nbSecret) {
        (*witness) = make(Witness, nbPublic + nbSecret)
    } else {
        (*witness) = (*witness)[:nbPublic + nbSecret]
    }

    var i, j int // indexes for secret / public variables
    i = nbPublic // offset

    collectHandler := func(f *schema.Field, tInput reflect.Value) error {
        if publicOnly && f.Visibility != schema.Public {
            return nil 
        }
        if tInput.IsNil() {
            return fmt.Errorf("when parsing variable %s: missing assignment", f.FullName)
        }
        v := tInput.Interface()

        if v == nil {
            return fmt.Errorf("when parsing variable %s: missing assignment", f.FullName) 
        }

        if !publicOnly && f.Visibility == schema.Secret {
            if _, err := (*witness)[i].SetInterface(v) ; err != nil {
                return fmt.Errorf("when parsing variable %s: %v", f.FullName, err) 
            }
            i++
        } else if f.Visibility == schema.Public {
            if _, err := (*witness)[j].SetInterface(v) ; err != nil {
                return fmt.Errorf("when parsing variable %s: %v", f.FullName, err) 
            }
            j++
        }
        return nil
    }
    return schema.ParseDeprecated(assignment, leafType,  collectHandler)
}

// ToAssignment sets to leaf values to witness underlying vector element values (in order)
// see witness.MarshalBinary protocol description 
func (witness *Witness) ToAssignment(assignment interface{}, leafType reflect.Type, publicOnly bool) {
    i := 0
	setAddr := leafType.Kind() == reflect.Ptr 
	setHandler := func(v schema.Visibility) schema.LeafHandlerDeprecated {
		return func(f *schema.Field, tInput reflect.Value) error {
			if f.Visibility == v {
				if setAddr {
					tInput.Set(reflect.ValueOf((&(*witness)[i])))
				} else {
					tInput.Set(reflect.ValueOf(((*witness)[i])))
				}
				
				i++
			}
			return nil
		}
	}
	_, _ = schema.ParseDeprecated(assignment, leafType, setHandler(schema.Public))
    if publicOnly {
        return
    }
    _, _ = schema.ParseDeprecated(assignment, leafType, setHandler(schema.Secret))

}

func (witness *Witness) String() string {
    var sbb strings.Builder
    sbb.WriteByte('[')
    for i:=0; i < len(*witness); i++ {
        sbb.WriteString((*witness)[i].String())
        sbb.WriteByte(',')
    }
    sbb.WriteByte(']')
    return sbb.String()
}


