// Package smt provides utilities for exporting gnark constraint systems to SMT solver formats.
//
// This package enables formal verification of gnark circuits using SMT solvers like cvc5.
// It exports the actual constraints generated by the gnark compiler (not manually written
// approximations) so that verification tests check the real PlonK constraints.
package smt

import (
	"fmt"
	"io"
	"math/big"
	"strings"

	"github.com/consensys/gnark/constraint"
	"github.com/consensys/gnark/debug"
)

// ConstraintExporter provides an interface for exporting constraint systems.
type ConstraintExporter interface {
	// GetSparseR1Cs returns all SparseR1C constraints
	GetSparseR1Cs() []constraint.SparseR1C
	// GetCoefficient returns the coefficient at index i
	GetCoefficient(i int) constraint.U64
	// GetNbCoefficients returns the number of coefficients
	GetNbCoefficients() int
	// Field returns the scalar field modulus
	Field() *big.Int
	// GetNbPublicVariables returns the number of public variables
	GetNbPublicVariables() int
	// GetNbSecretVariables returns the number of secret variables
	GetNbSecretVariables() int
	// GetNbInternalVariables returns the number of internal variables
	GetNbInternalVariables() int
	// VariableToString returns the name of variable vID
	VariableToString(vID int) string
	// CoeffToString returns the string representation of coefficient cID
	CoeffToString(cID int) string
	// ToBigInt converts a coefficient to big.Int
	ToBigInt(c constraint.U64) *big.Int
}

// HintExporter provides interface for exporting hint information.
// This is optional - not all constraint systems expose this.
type HintExporter interface {
	// GetNbInstructions returns total number of instructions
	GetNbInstructions() int
	// GetInstruction returns instruction at index i
	GetInstruction(i int) constraint.Instruction
}

// DebugInfoExporter provides interface for extracting debug/profile info.
// This enables source location tracking for constraints and variables.
type DebugInfoExporter interface {
	// GetDebugInfo returns debug info entries
	GetDebugInfo() []constraint.LogEntry
	// GetSymbolTable returns the symbol table
	GetSymbolTable() debug.SymbolTable
	// GetMDebug returns constraint ID to debug info ID mapping
	GetMDebug() map[int]int
}

// ExtractedHint represents a hint with its outputs.
type ExtractedHint struct {
	// Index of this hint in the instruction list
	Index int
	// HintID is the identifier for the hint function
	HintID uint32
	// OutputStart is the first variable ID output by this hint
	OutputStart uint32
	// OutputEnd is one past the last variable ID output by this hint
	OutputEnd uint32
	// OutputVarNames are the names of the output variables
	OutputVarNames []string
}

// ExportConfig configures the export behavior.
type ExportConfig struct {
	// IncludeComments adds human-readable comments to the output
	IncludeComments bool
	// VariablePrefix is prepended to variable names (default: "w")
	VariablePrefix string
	// MaxConstraints limits the number of constraints exported (0 = no limit)
	MaxConstraints int
}

// DefaultConfig returns the default export configuration.
func DefaultConfig() ExportConfig {
	return ExportConfig{
		IncludeComments: true,
		VariablePrefix:  "w",
		MaxConstraints:  0,
	}
}

// ExtractedConstraint represents a single PlonK constraint with resolved values.
type ExtractedConstraint struct {
	// Variable IDs
	XA, XB, XC uint32
	// Coefficient values (as big.Int)
	QL, QR, QO, QM, QC *big.Int
	// Human-readable constraint string
	String string
}

// ExtractedSystem contains all extracted data from a constraint system.
type ExtractedSystem struct {
	// Field modulus
	Field *big.Int
	// Variable counts
	NbPublic, NbSecret, NbInternal int
	// All unique coefficients
	Coefficients []*big.Int
	// All constraints
	Constraints []ExtractedConstraint
	// Variable names (index -> name)
	VariableNames []string
	// Hints and their output variables
	Hints []ExtractedHint
	// HintOutputVars maps variable ID to true if it's a hint output
	HintOutputVars map[uint32]bool
}

// Extract extracts all constraints and metadata from a constraint system.
func Extract(cs ConstraintExporter) *ExtractedSystem {
	result := &ExtractedSystem{
		Field:          cs.Field(),
		NbPublic:       cs.GetNbPublicVariables(),
		NbSecret:       cs.GetNbSecretVariables(),
		NbInternal:     cs.GetNbInternalVariables(),
		HintOutputVars: make(map[uint32]bool),
	}

	// Extract all coefficients
	nbCoeffs := cs.GetNbCoefficients()
	result.Coefficients = make([]*big.Int, nbCoeffs)
	for i := 0; i < nbCoeffs; i++ {
		coeff := cs.GetCoefficient(i)
		result.Coefficients[i] = cs.ToBigInt(coeff)
	}

	// Extract variable names
	totalVars := result.NbPublic + result.NbSecret + result.NbInternal
	result.VariableNames = make([]string, totalVars)
	for i := 0; i < totalVars; i++ {
		result.VariableNames[i] = cs.VariableToString(i)
	}

	// Extract all constraints
	sparseR1Cs := cs.GetSparseR1Cs()
	result.Constraints = make([]ExtractedConstraint, len(sparseR1Cs))

	for i, c := range sparseR1Cs {
		result.Constraints[i] = ExtractedConstraint{
			XA: c.XA,
			XB: c.XB,
			XC: c.XC,
			QL: result.Coefficients[c.QL],
			QR: result.Coefficients[c.QR],
			QO: result.Coefficients[c.QO],
			QM: result.Coefficients[c.QM],
			QC: result.Coefficients[c.QC],
			String: formatConstraint(c, cs),
		}
	}

	// Try to extract hints if the interface is available
	if hintExp, ok := cs.(HintExporter); ok {
		result.Hints = extractHints(hintExp, result.VariableNames, result.NbPublic, result.NbSecret)
		for _, h := range result.Hints {
			for v := h.OutputStart; v < h.OutputEnd; v++ {
				result.HintOutputVars[v] = true
			}
		}
	}

	return result
}

// extractHints extracts hint information from instructions.
// nbPublic and nbSecret are used to filter out false positives.
func extractHints(cs HintExporter, varNames []string, nbPublic, nbSecret int) []ExtractedHint {
	var hints []ExtractedHint

	// Internal variables start after public + secret
	internalStart := uint32(nbPublic + nbSecret)

	nbInst := cs.GetNbInstructions()
	for i := 0; i < nbInst; i++ {
		inst := cs.GetInstruction(i)

		// Check if this looks like a hint instruction
		// Hint instructions have calldata[0] > 2 (nb inputs encoding)
		// and specific structure
		if len(inst.Calldata) < 4 {
			continue
		}

		// Try to parse as hint - hint format:
		// [nbInputs, hintID, lenInputs, ...inputs..., outputStart, outputEnd]
		nbFields := int(inst.Calldata[0])
		if nbFields < 4 || nbFields > len(inst.Calldata) {
			continue
		}

		// The last two fields are outputStart and outputEnd
		outputStart := inst.Calldata[len(inst.Calldata)-2]
		outputEnd := inst.Calldata[len(inst.Calldata)-1]

		// Sanity check - outputs should be a reasonable range
		if outputEnd <= outputStart || outputEnd-outputStart > 1000 {
			continue
		}

		// Hint outputs must be internal variables, not public/secret inputs
		// Public/secret are inputs defined by the circuit, not computed by hints
		if outputStart < internalStart {
			continue
		}

		hintID := inst.Calldata[1]

		// Get output variable names
		var outputNames []string
		for v := outputStart; v < outputEnd; v++ {
			if int(v) < len(varNames) {
				outputNames = append(outputNames, varNames[v])
			} else {
				outputNames = append(outputNames, fmt.Sprintf("v%d", v))
			}
		}

		hints = append(hints, ExtractedHint{
			Index:          i,
			HintID:         hintID,
			OutputStart:    outputStart,
			OutputEnd:      outputEnd,
			OutputVarNames: outputNames,
		})
	}

	return hints
}

func formatConstraint(c constraint.SparseR1C, cs ConstraintExporter) string {
	var parts []string

	ql := cs.CoeffToString(int(c.QL))
	qr := cs.CoeffToString(int(c.QR))
	qo := cs.CoeffToString(int(c.QO))
	qm := cs.CoeffToString(int(c.QM))
	qc := cs.CoeffToString(int(c.QC))

	xa := cs.VariableToString(int(c.XA))
	xb := cs.VariableToString(int(c.XB))
	xc := cs.VariableToString(int(c.XC))

	if ql != "0" {
		parts = append(parts, fmt.Sprintf("%s*%s", ql, xa))
	}
	if qr != "0" {
		parts = append(parts, fmt.Sprintf("%s*%s", qr, xb))
	}
	if qo != "0" {
		parts = append(parts, fmt.Sprintf("%s*%s", qo, xc))
	}
	if qm != "0" {
		parts = append(parts, fmt.Sprintf("%s*%s*%s", qm, xa, xb))
	}
	if qc != "0" {
		parts = append(parts, qc)
	}

	if len(parts) == 0 {
		return "0 == 0"
	}
	return strings.Join(parts, " + ") + " == 0"
}

// ExportSMTLIB2 exports the constraint system to SMT-LIB2 format.
func ExportSMTLIB2(w io.Writer, cs ConstraintExporter, cfg ExportConfig) error {
	ext := Extract(cs)

	// Header
	fmt.Fprintln(w, "; Gnark SCS constraint system export")
	fmt.Fprintf(w, "; Field: %s\n", ext.Field.String())
	fmt.Fprintf(w, "; Variables: %d public, %d secret, %d internal\n",
		ext.NbPublic, ext.NbSecret, ext.NbInternal)
	fmt.Fprintf(w, "; Constraints: %d\n\n", len(ext.Constraints))

	fmt.Fprintln(w, "(set-logic QF_FF)")
	fmt.Fprintf(w, "(define-sort F () (_ FiniteField %s))\n\n", ext.Field.String())

	// Declare variables
	totalVars := ext.NbPublic + ext.NbSecret + ext.NbInternal
	for i := 0; i < totalVars; i++ {
		name := ext.VariableNames[i]
		if cfg.VariablePrefix != "" {
			name = fmt.Sprintf("%s%d", cfg.VariablePrefix, i)
		}
		fmt.Fprintf(w, "(declare-const %s F)\n", name)
	}
	fmt.Fprintln(w)

	// Define zero constant
	fmt.Fprintf(w, "(define-const zero F (as ff0 F))\n\n")

	// Export constraints
	maxConstraints := len(ext.Constraints)
	if cfg.MaxConstraints > 0 && cfg.MaxConstraints < maxConstraints {
		maxConstraints = cfg.MaxConstraints
	}

	for i := 0; i < maxConstraints; i++ {
		c := ext.Constraints[i]
		if cfg.IncludeComments {
			fmt.Fprintf(w, "; Constraint %d: %s\n", i, c.String)
		}

		// Build the PlonK constraint: qL*xa + qR*xb + qO*xc + qM*(xa*xb) + qC == 0
		xa := fmt.Sprintf("%s%d", cfg.VariablePrefix, c.XA)
		xb := fmt.Sprintf("%s%d", cfg.VariablePrefix, c.XB)
		xc := fmt.Sprintf("%s%d", cfg.VariablePrefix, c.XC)

		// Build sum of terms
		var terms []string

		if c.QL.Sign() != 0 {
			terms = append(terms, fmt.Sprintf("(ff.mul (as ff%s F) %s)", c.QL.String(), xa))
		}
		if c.QR.Sign() != 0 {
			terms = append(terms, fmt.Sprintf("(ff.mul (as ff%s F) %s)", c.QR.String(), xb))
		}
		if c.QO.Sign() != 0 {
			terms = append(terms, fmt.Sprintf("(ff.mul (as ff%s F) %s)", c.QO.String(), xc))
		}
		if c.QM.Sign() != 0 {
			terms = append(terms, fmt.Sprintf("(ff.mul (as ff%s F) (ff.mul %s %s))",
				c.QM.String(), xa, xb))
		}
		if c.QC.Sign() != 0 {
			terms = append(terms, fmt.Sprintf("(as ff%s F)", c.QC.String()))
		}

		if len(terms) == 0 {
			fmt.Fprintln(w, "(assert (= zero zero))")
		} else {
			// Build nested ff.add
			expr := terms[0]
			for j := 1; j < len(terms); j++ {
				expr = fmt.Sprintf("(ff.add %s %s)", expr, terms[j])
			}
			fmt.Fprintf(w, "(assert (= %s zero))\n", expr)
		}
		fmt.Fprintln(w)
	}

	fmt.Fprintln(w, "(check-sat)")
	return nil
}

// ExportCVC5Cpp exports the constraint system to C++ code using cvc5 API.
func ExportCVC5Cpp(w io.Writer, cs ConstraintExporter, cfg ExportConfig, testName string) error {
	ext := Extract(cs)

	// Header
	fmt.Fprintln(w, "// Auto-generated from gnark constraint system")
	fmt.Fprintln(w, "// Do not edit manually")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "#include <cvc5/cvc5.h>")
	fmt.Fprintln(w, "#include <iostream>")
	fmt.Fprintln(w, "#include <string>")
	fmt.Fprintln(w, "#include <vector>")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "using namespace std;")
	fmt.Fprintln(w, "using namespace cvc5;")
	fmt.Fprintln(w)

	// Field constant
	fmt.Fprintf(w, "// Scalar field modulus\n")
	fmt.Fprintf(w, "const string FIELD_MODULUS = \"%s\";\n\n", ext.Field.String())

	// Variable counts
	fmt.Fprintf(w, "// Variable counts\n")
	fmt.Fprintf(w, "const int NB_PUBLIC = %d;\n", ext.NbPublic)
	fmt.Fprintf(w, "const int NB_SECRET = %d;\n", ext.NbSecret)
	fmt.Fprintf(w, "const int NB_INTERNAL = %d;\n", ext.NbInternal)
	fmt.Fprintf(w, "const int NB_TOTAL = %d;\n", ext.NbPublic+ext.NbSecret+ext.NbInternal)
	fmt.Fprintf(w, "const int NB_CONSTRAINTS = %d;\n\n", len(ext.Constraints))

	// Helper functions
	fmt.Fprint(w, `// Helper functions
Term mkFieldElem(TermManager& tm, Sort& field, const string& value) {
    return tm.mkFiniteFieldElem(value, field);
}

Term ffAdd(TermManager& tm, Term a, Term b) {
    return tm.mkTerm(Kind::FINITE_FIELD_ADD, {a, b});
}

Term ffMul(TermManager& tm, Term a, Term b) {
    return tm.mkTerm(Kind::FINITE_FIELD_MULT, {a, b});
}

Term ffEqual(TermManager& tm, Sort& field, Term a, Term b) {
    Term zero = mkFieldElem(tm, field, "0");
    Term negOne = mkFieldElem(tm, field, "-1");
    Term diff = ffAdd(tm, a, ffMul(tm, negOne, b));
    return tm.mkTerm(Kind::EQUAL, {diff, zero});
}
`)

	// Constraint data structure
	fmt.Fprint(w, `
// Constraint structure matching gnark's SparseR1C
struct PlonkConstraint {
    int xa, xb, xc;      // Variable indices
    string qL, qR, qO;   // Linear coefficients
    string qM, qC;       // Multiplication and constant coefficients
    string description;  // Human-readable description
};
`)

	// Export constraint data
	fmt.Fprintln(w, "// All constraints from the compiled circuit")
	fmt.Fprintln(w, "const vector<PlonkConstraint> CONSTRAINTS = {")

	maxConstraints := len(ext.Constraints)
	if cfg.MaxConstraints > 0 && cfg.MaxConstraints < maxConstraints {
		maxConstraints = cfg.MaxConstraints
	}

	for i := 0; i < maxConstraints; i++ {
		c := ext.Constraints[i]
		fmt.Fprintf(w, "    {%d, %d, %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\"}",
			c.XA, c.XB, c.XC,
			c.QL.String(), c.QR.String(), c.QO.String(),
			c.QM.String(), c.QC.String(),
			escapeString(c.String))
		if i < maxConstraints-1 {
			fmt.Fprintln(w, ",")
		} else {
			fmt.Fprintln(w)
		}
	}
	fmt.Fprintln(w, "};")
	fmt.Fprintln(w)

	// Variable names
	fmt.Fprintln(w, "// Variable names for debugging")
	fmt.Fprintln(w, "const vector<string> VAR_NAMES = {")
	for i, name := range ext.VariableNames {
		fmt.Fprintf(w, "    \"%s\"", escapeString(name))
		if i < len(ext.VariableNames)-1 {
			fmt.Fprintln(w, ",")
		} else {
			fmt.Fprintln(w)
		}
	}
	fmt.Fprintln(w, "};")
	fmt.Fprintln(w)

	// Function to create and assert all constraints
	fmt.Fprintf(w, `
// Creates cvc5 variables for all wires
vector<Term> createVariables(TermManager& tm, Sort& field) {
    vector<Term> vars(NB_TOTAL);
    for (int i = 0; i < NB_TOTAL; i++) {
        vars[i] = tm.mkConst(field, VAR_NAMES[i]);
    }
    return vars;
}

// Builds a single PlonK constraint term: qL*xa + qR*xb + qO*xc + qM*(xa*xb) + qC
Term buildConstraintTerm(TermManager& tm, Sort& field,
                         const vector<Term>& vars, const PlonkConstraint& c) {
    Term zero = mkFieldElem(tm, field, "0");
    Term result = zero;

    if (c.qL != "0") {
        result = ffAdd(tm, result, ffMul(tm, mkFieldElem(tm, field, c.qL), vars[c.xa]));
    }
    if (c.qR != "0") {
        result = ffAdd(tm, result, ffMul(tm, mkFieldElem(tm, field, c.qR), vars[c.xb]));
    }
    if (c.qO != "0") {
        result = ffAdd(tm, result, ffMul(tm, mkFieldElem(tm, field, c.qO), vars[c.xc]));
    }
    if (c.qM != "0") {
        result = ffAdd(tm, result, ffMul(tm, mkFieldElem(tm, field, c.qM),
                                          ffMul(tm, vars[c.xa], vars[c.xb])));
    }
    if (c.qC != "0") {
        result = ffAdd(tm, result, mkFieldElem(tm, field, c.qC));
    }

    return result;
}

// Asserts all constraints in the solver
void assertAllConstraints(Solver& solver, TermManager& tm, Sort& field,
                          const vector<Term>& vars) {
    Term zero = mkFieldElem(tm, field, "0");
    for (const auto& c : CONSTRAINTS) {
        Term constraintTerm = buildConstraintTerm(tm, field, vars, c);
        solver.assertFormula(tm.mkTerm(Kind::EQUAL, {constraintTerm, zero}));
    }
}
`)

	// Test function template
	fmt.Fprintf(w, `
// Example test: verify the constraints are satisfiable with a valid witness
bool test%sSatisfiable() {
    TermManager tm;
    Solver solver(tm);
    solver.setOption("produce-models", "true");

    Sort field = tm.mkFiniteFieldSort(FIELD_MODULUS);
    vector<Term> vars = createVariables(tm, field);

    assertAllConstraints(solver, tm, field, vars);

    Result r = solver.checkSat();
    return r.isSat();
}

// Example test: verify constraint count matches expected
bool test%sConstraintCount() {
    return CONSTRAINTS.size() == NB_CONSTRAINTS;
}

int main() {
    cout << "========================================" << endl;
    cout << "Gnark Constraint System Verification" << endl;
    cout << "========================================" << endl;
    cout << "Field: " << FIELD_MODULUS << endl;
    cout << "Variables: " << NB_PUBLIC << " public, " << NB_SECRET << " secret, " << NB_INTERNAL << " internal" << endl;
    cout << "Constraints: " << NB_CONSTRAINTS << endl;
    cout << endl;

    int passed = 0, failed = 0;

    if (test%sConstraintCount()) {
        cout << "PASS: Constraint count matches" << endl;
        passed++;
    } else {
        cout << "FAIL: Constraint count mismatch" << endl;
        failed++;
    }

    if (test%sSatisfiable()) {
        cout << "PASS: Constraints are satisfiable" << endl;
        passed++;
    } else {
        cout << "FAIL: Constraints are not satisfiable" << endl;
        failed++;
    }

    cout << endl;
    cout << "Summary: " << passed << " passed, " << failed << " failed" << endl;

    return failed > 0 ? 1 : 0;
}
`, testName, testName, testName, testName)

	return nil
}

func escapeString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "\n", "\\n")
	return s
}
