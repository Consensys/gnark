// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package cs

import (
	"fmt"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/fxamacker/cbor/v2"
	"io"
	"math/big"
	"os"
	"strings"
	"text/template"

	"github.com/consensys/gnark/backend"
	"github.com/consensys/gnark/internal/backend/compiled"
	"github.com/consensys/gnark/internal/backend/ioutils"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
)

// SparseR1CS represents a Plonk like circuit
type SparseR1CS struct {
	compiled.SparseR1CS

	Coefficients []fr.Element // coefficients in the constraints
	loggerOut    io.Writer
}

// NewSparseR1CS returns a new SparseR1CS and sets r1cs.Coefficient (fr.Element) from provided big.Int values
func NewSparseR1CS(ccs compiled.SparseR1CS, coefficients []big.Int) *SparseR1CS {
	cs := SparseR1CS{
		SparseR1CS:   ccs,
		Coefficients: make([]fr.Element, len(coefficients)),
		loggerOut:    os.Stdout,
	}
	for i := 0; i < len(coefficients); i++ {
		cs.Coefficients[i].SetBigInt(&coefficients[i])
	}

	return &cs
}

// Solve sets all the wires.
// solution.values =  [publicInputs | secretInputs | internalVariables ]
// witness: contains the input variables
// it returns the full slice of wires
func (cs *SparseR1CS) Solve(witness []fr.Element, opt backend.ProverOption) ([]fr.Element, error) {

	// set the slices holding the solution.values and monitoring which variables have been solved
	nbVariables := cs.NbInternalVariables + cs.NbSecretVariables + cs.NbPublicVariables

	expectedWitnessSize := int(cs.NbPublicVariables + cs.NbSecretVariables)
	if len(witness) != expectedWitnessSize {
		return make([]fr.Element, nbVariables), fmt.Errorf(
			"invalid witness size, got %d, expected %d = %d (public) + %d (secret)",
			len(witness),
			expectedWitnessSize,
			cs.NbPublicVariables,
			cs.NbSecretVariables,
		)
	}

	// keep track of wire that have a value
	solution, err := newSolution(nbVariables, opt.HintFunctions, cs.Coefficients)
	if err != nil {
		return solution.values, err
	}

	// solution.values = [publicInputs | secretInputs | internalVariables ] -> we fill publicInputs | secretInputs
	copy(solution.values, witness)
	for i := 0; i < len(witness); i++ {
		solution.solved[i] = true
	}

	// keep track of the number of wire instantiations we do, for a sanity check to ensure
	// we instantiated all wires
	solution.nbSolved += len(witness)

	// defer log printing once all solution.values are computed
	defer solution.printLogs(opt.LoggerOut, cs.Logs)

	// batch invert the coefficients to avoid many divisions in the solver
	coefficientsNegInv := fr.BatchInvert(cs.Coefficients)
	for i := 0; i < len(coefficientsNegInv); i++ {
		coefficientsNegInv[i].Neg(&coefficientsNegInv[i])
	}

	// loop through the constraints to solve the variables
	for i := 0; i < len(cs.Constraints); i++ {
		if err := cs.solveConstraint(cs.Constraints[i], &solution, coefficientsNegInv); err != nil {
			return solution.values, fmt.Errorf("constraint %d: %w", i, err)
		}
		if err := cs.checkConstraint(cs.Constraints[i], &solution); err != nil {
			if dID, ok := cs.MDebug[i]; ok {
				debugInfoStr := solution.logValue(cs.DebugInfo[dID])
				return solution.values, fmt.Errorf("%w: %s", ErrUnsatisfiedConstraint, debugInfoStr)
			}
			return solution.values, ErrUnsatisfiedConstraint
		}
	}

	// sanity check; ensure all wires are marked as "instantiated"
	if !solution.isValid() {
		panic("solver didn't instantiate all wires")
	}

	return solution.values, nil

}

// computeHints computes wires associated with a hint function, if any
// if there is no remaining wire to solve, returns -1
// else returns the wire position (L -> 0, R -> 1, O -> 2)
func (cs *SparseR1CS) computeHints(c compiled.SparseR1C, solution *solution) (int, error) {
	r := -1
	lID, rID, oID := c.L.VariableID(), c.R.VariableID(), c.O.VariableID()

	if (c.L.CoeffID() != 0 || c.M[0].CoeffID() != 0) && !solution.solved[lID] {
		// check if it's a hint
		if hint, ok := cs.MHints[lID]; ok {
			if err := solution.solveWithHint(lID, hint); err != nil {
				return -1, err
			}
		} else {
			r = 0
		}

	}

	if (c.R.CoeffID() != 0 || c.M[1].CoeffID() != 0) && !solution.solved[rID] {
		// check if it's a hint
		if hint, ok := cs.MHints[rID]; ok {
			if err := solution.solveWithHint(rID, hint); err != nil {
				return -1, err
			}
		} else {
			r = 1
		}
	}

	if (c.O.CoeffID() != 0) && !solution.solved[oID] {
		// check if it's a hint
		if hint, ok := cs.MHints[oID]; ok {
			if err := solution.solveWithHint(oID, hint); err != nil {
				return -1, err
			}
		} else {
			r = 2
		}
	}
	return r, nil
}

// solveConstraint solve any unsolved wire in given constraint and update the solution
// a SparseR1C may have up to one unsolved wire (excluding hints)
// if it doesn't, then this function returns and does nothing
func (cs *SparseR1CS) solveConstraint(c compiled.SparseR1C, solution *solution, coefficientsNegInv []fr.Element) error {

	lro, err := cs.computeHints(c, solution)
	if err != nil {
		return err
	}
	if lro == -1 {
		// no unsolved wire
		// can happen if the constraint contained only hint wires.
		return nil
	}
	if lro == 1 {
		panic("unsolved wire in R; shouldn't happen as frontend puts unsolved wire in L")
	}

	if lro == 0 { // we solve for L: u1L+u2R+u3LR+u4O+k=0 => L(u1+u3R)+u2R+u4O+k = 0
		if !solution.solved[c.R.VariableID()] {
			panic("R wire should be instantiated when we solve L")
		}
		var u1, u2, u3, den, num, v1, v2 fr.Element
		u3.Mul(&cs.Coefficients[c.M[0].CoeffID()], &cs.Coefficients[c.M[1].CoeffID()])
		u1.Set(&cs.Coefficients[c.L.CoeffID()])
		u2.Set(&cs.Coefficients[c.R.CoeffID()])
		den.Mul(&u3, &solution.values[c.R.VariableID()]).Add(&den, &u1)

		v1 = solution.computeTerm(c.R)
		v2 = solution.computeTerm(c.O)
		num.Add(&v1, &v2).Add(&num, &cs.Coefficients[c.K])

		// TODO find a way to do lazy div (/ batch inversion)
		num.Div(&num, &den).Neg(&num)
		solution.set(c.L.VariableID(), num)
		return nil

	}
	// O we solve for O
	var o fr.Element
	cID, vID, _ := c.O.Unpack()

	l := solution.computeTerm(c.L)
	r := solution.computeTerm(c.R)
	m0 := solution.computeTerm(c.M[0])
	m1 := solution.computeTerm(c.M[1])

	// o = - ((m0 * m1) + l + r + c.K) / c.O
	o.Mul(&m0, &m1).Add(&o, &l).Add(&o, &r).Add(&o, &cs.Coefficients[c.K])
	o.Mul(&o, &coefficientsNegInv[cID])

	solution.set(vID, o)

	return nil
}

// IsSolved returns nil if given witness solves the R1CS and error otherwise
// this method wraps r1cs.Solve() and allocates r1cs.Solve() inputs
func (cs *SparseR1CS) IsSolved(witness []fr.Element, opt backend.ProverOption) error {
	_, err := cs.Solve(witness, opt)
	return err
}

// checkConstraint verifies that the constraint holds
func (cs *SparseR1CS) checkConstraint(c compiled.SparseR1C, solution *solution) error {
	l := solution.computeTerm(c.L)
	r := solution.computeTerm(c.R)
	m0 := solution.computeTerm(c.M[0])
	m1 := solution.computeTerm(c.M[1])
	o := solution.computeTerm(c.O)

	// l + r + (m0 * m1) + o + c.K == 0
	var t fr.Element
	t.Mul(&m0, &m1).Add(&t, &l).Add(&t, &r).Add(&t, &o).Add(&t, &cs.Coefficients[c.K])
	if !t.IsZero() {
		return fmt.Errorf("%w\n%s + %s + (%s * %s) + %s + %s != 0", ErrUnsatisfiedConstraint,
			l.String(),
			r.String(),
			m0.String(),
			m1.String(),
			o.String(),
			cs.Coefficients[c.K].String(),
		)
	}
	return nil

}

// ToHTML returns an HTML human-readable representation of the constraint system
func (cs *SparseR1CS) ToHTML(w io.Writer) error {
	t, err := template.New("scs.html").Funcs(template.FuncMap{
		"toHTML":      toHTMLTerm,
		"toHTMLCoeff": toHTMLCoeff,
		"add":         add,
		"sub":         sub,
	}).Parse(compiled.SparseR1CSTemplate)
	if err != nil {
		return err
	}

	return t.Execute(w, cs)
}

func toHTMLTerm(t compiled.Term, coeffs []fr.Element, MHints map[int]int) string {
	var sbb strings.Builder
	termToHTML(t, &sbb, coeffs, MHints, true)
	return sbb.String()
}

func toHTMLCoeff(cID int, coeffs []fr.Element) string {
	if cID == compiled.CoeffIdMinusOne {
		// print neg sign
		return "<span class=\"coefficient\">-1</span>"
	}
	var sbb strings.Builder
	sbb.WriteString("<span class=\"coefficient\">")
	sbb.WriteString(coeffs[cID].String())
	sbb.WriteString("</span>")
	return sbb.String()
}

// FrSize return fr.Limbs * 8, size in byte of a fr element
func (cs *SparseR1CS) FrSize() int {
	return fr.Limbs * 8
}

// GetNbCoefficients return the number of unique coefficients needed in the R1CS
func (cs *SparseR1CS) GetNbCoefficients() int {
	return len(cs.Coefficients)
}

// CurveID returns curve ID as defined in gnark-crypto (ecc.BN254)
func (cs *SparseR1CS) CurveID() ecc.ID {
	return ecc.BN254
}

// WriteTo encodes SparseR1CS into provided io.Writer using cbor
func (cs *SparseR1CS) WriteTo(w io.Writer) (int64, error) {
	_w := ioutils.WriterCounter{W: w} // wraps writer to count the bytes written
	enc, err := cbor.CoreDetEncOptions().EncMode()
	if err != nil {
		return 0, err
	}
	encoder := enc.NewEncoder(&_w)

	// encode our object
	err = encoder.Encode(cs)
	return _w.N, err
}

// ReadFrom attempts to decode SparseR1CS from io.Reader using cbor
func (cs *SparseR1CS) ReadFrom(r io.Reader) (int64, error) {
	dm, err := cbor.DecOptions{MaxArrayElements: 134217728}.DecMode()
	if err != nil {
		return 0, err
	}
	decoder := dm.NewDecoder(r)
	err = decoder.Decode(cs)
	return int64(decoder.NumBytesRead()), err
}

// SetLoggerOutput replace existing logger output with provided one
// default uses os.Stdout
// if nil is provided, logs are not printed
func (cs *SparseR1CS) SetLoggerOutput(w io.Writer) {
	cs.loggerOut = w
}
