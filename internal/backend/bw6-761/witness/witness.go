// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package witness

import (
	"encoding/binary"
	"fmt"
	"io"
	"reflect"
	"strings"

	"github.com/consensys/gnark/frontend/schema"

	"github.com/consensys/gnark-crypto/ecc/bw6-761/fr"
)

type Witness []fr.Element

// WriteTo encodes witness to writer (implements io.WriterTo)
func (witness *Witness) WriteTo(w io.Writer) (int64, error) {
	// encode slice length
	if err := binary.Write(w, binary.BigEndian, uint32(len(*witness))); err != nil {
		return 0, err
	}

	n := int64(4)

	var buf [fr.Bytes]byte
	for i := 0; i < len(*witness); i++ {
		buf = (*witness)[i].Bytes()
		m, err := w.Write(buf[:])
		n += int64(m)
		if err != nil {
			return n, err
		}
	}
	return n, nil
}

func (witness *Witness) Len() int {
	return len(*witness)
}

func (witness *Witness) Type() reflect.Type {
	return reflect.TypeOf(fr.Element{})
}

func (witness *Witness) ReadFrom(r io.Reader) (int64, error) {

	var buf [fr.Bytes]byte
	if read, err := io.ReadFull(r, buf[:4]); err != nil {
		return int64(read), err
	}
	sliceLen := binary.BigEndian.Uint32(buf[:4])

	n := int64(4)

	if len(*witness) != int(sliceLen) {
		*witness = make([]fr.Element, sliceLen)
	}

	for i := 0; i < int(sliceLen); i++ {
		read, err := io.ReadFull(r, buf[:])
		n += int64(read)
		if err != nil {
			return n, err
		}
		(*witness)[i].SetBytes(buf[:])
	}

	return n, nil
}

// FromAssignment extracts the witness and its schema
func (witness *Witness) FromAssignment(assignment interface{}, leafType reflect.Type, publicOnly bool) (*schema.Schema, error) {
	s, err := schema.Walk(assignment, leafType, nil)
	if err != nil {
		return nil, err
	}
	nbSecret, nbPublic := s.Secret, s.Public

	if publicOnly {
		nbSecret = 0
	}

	if len(*witness) < (nbPublic + nbSecret) {
		(*witness) = make(Witness, nbPublic+nbSecret)
	} else {
		(*witness) = (*witness)[:nbPublic+nbSecret]
	}

	var i, j int // indexes for secret / public variables
	i = nbPublic // offset

	collectHandler := func(f schema.LeafInfo, tInput reflect.Value) error {
		if publicOnly && f.Visibility != schema.Public {
			return nil
		}
		if tInput.IsNil() {
			return fmt.Errorf("when parsing variable %s: missing assignment", f.FullName())
		}
		v := tInput.Interface()

		if v == nil {
			return fmt.Errorf("when parsing variable %s: missing assignment", f.FullName())
		}

		if !publicOnly && f.Visibility == schema.Secret {
			if _, err := (*witness)[i].SetInterface(v); err != nil {
				return fmt.Errorf("when parsing variable %s: %v", f.FullName(), err)
			}
			i++
		} else if f.Visibility == schema.Public {
			if _, err := (*witness)[j].SetInterface(v); err != nil {
				return fmt.Errorf("when parsing variable %s: %v", f.FullName(), err)
			}
			j++
		}
		return nil
	}
	if _, err := schema.Walk(assignment, leafType, collectHandler); err != nil {
		return nil, err
	}
	return schema.New(assignment, leafType)
}

// ToAssignment sets to leaf values to witness underlying vector element values (in order)
// see witness.MarshalBinary protocol description
func (witness *Witness) ToAssignment(assignment interface{}, leafType reflect.Type, publicOnly bool) {
	i := 0
	setAddr := leafType.Kind() == reflect.Ptr
	setHandler := func(v schema.Visibility) schema.LeafHandler {
		return func(f schema.LeafInfo, tInput reflect.Value) error {
			if f.Visibility == v {
				if setAddr {
					tInput.Set(reflect.ValueOf((&(*witness)[i])))
				} else {
					tInput.Set(reflect.ValueOf(((*witness)[i])))
				}

				i++
			}
			return nil
		}
	}
	_, _ = schema.Walk(assignment, leafType, setHandler(schema.Public))
	if publicOnly {
		return
	}
	_, _ = schema.Walk(assignment, leafType, setHandler(schema.Secret))

}

func (witness *Witness) String() string {
	var sbb strings.Builder
	sbb.WriteByte('[')
	for i := 0; i < len(*witness); i++ {
		sbb.WriteString((*witness)[i].String())
		sbb.WriteByte(',')
	}
	sbb.WriteByte(']')
	return sbb.String()
}
